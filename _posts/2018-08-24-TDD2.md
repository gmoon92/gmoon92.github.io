---
layout: post
title: "TDD : Unit Test With JUnit"
tags: [TDD]
display: "false"
subtitle: "Chapter2 자동화 테스트"
excerpt_separator: <!--more-->
sitemap:
changefreq: daily
priority: 1.0
---

<!--more-->

# Chapter2. 자동화 테스트

---

### 단위 테스트

<img src="/md/img/TDD/UnitTest/unittest.png">
<em>단위 테스트</em>

 단위 테스트는 코드를 테스트한 다음 자동화된 방식으로 테스트를 실행하는 코드 작성 방법이다.

일반적으로 단위 테스트는 객체 또는 모듈의 함수 자바에서는 클래스에 초점을 맞춰 작성하고 기능의 목적에 따라 각 부분으로 분리하여 테스트를 진행한다. 이러한 세션 단위의 테스트를 하는 목적은 개별 부분을 검증하기 위함이다.

### 자동화 테스트의 필요성

테스트의 주요 이점은 오류를 예방하고 발견하는 것이다. 

개발 단계에서 발견된 오류는 비용을 절감하는 효과가 나타난다.
그 이유인즉슨 개발 중에 발견된 오류를 제거하는 것은 안정화 단계에서 같은 오류를 제거하는 것보다 훨씬 저렴하기 때문이다.

초기 오류 식별의 엄청난 절감 가능성 외에도 단위 테스트를 통해 더 많은 이점을 얻을 수 있다. 
TFD 방식으로 생성된 단위 테스트는 개발 중에 재설계가 이루어지기 때문에 `Clean Architecture`의 발판이 된다.

또한, 단위 테스트는 비용이 절감되는 효과가 나타난다.
단위 테스트에 대한 오류는 테스트 된 클래스에서 일반적으로 발견된다. 이 오류는 개발 단계에서 발견되기 때문에 비용이 절감되는 효과가 나타난다.

> An error found during the coding or unit testing phase is cheaper by a factor of 10, compared to when it is found in the system test. This factor rises to 100 for errors found as late as during the software's productive use. - IBM [Subramaniam99]

이러한 효과는 IBM이 실시한 연구결과를 통해 입증할 수 있다. '계발 단계에서 발견된 오류는 안정화 단계에서 발견된 것보다 10배 저렴하다. 소프트웨어가 사용자에게 오픈된 상태에서 발견된 오류는 그 수치가 100배로 상승한다.'

<img src="/md/img/TDD/UnitTest/automatedtest-graph.png">
<em>수동 테스트와 자동화 테스트의 비용 비교</em>

위 그래프를 보면 초기 드는 비용은 자동화된 테스트가 높다. 어찌 보면 당연한 결과일 수 있다.
하지만 테스트를 하는 횟수가 증가함에 따라 자동화 테스트 대비 수동 테스트의 비용이 기하급수적으로 증가함을 알 수 있다.

---

### JUnit

단위 테스트 작성 기준에 있어 Selef-Validating는 핵심이다. Selef-Validating은 수동 테스트가 아닌 자동화 테스트가 되어야 한다는 의미이다. 또한, 테스트 결과가 올바른지에 대한 판단은 개발자가 임의로 결정해서는 안 된다.

즉 테스트를 검증하는 도구가 필요하다.

JUnit은 Java 진영에서의 테스트 검증을 지원하는 대표적인 라이브러리이다. GUI 기반으로 설계되어 테스트 결과에 대해 직관적으로 볼 수 있고. jar 파일로 설정이 간단한 편이다.

>단위 테스트 프레임워크는 켄트 벡(Kent Beck)이 고안한 것으로, SUnit이라는 이름으로 Smalltalk에 처음 적용됐다. 이후 에릭 감마(Erich Gamma)와 켄트 벡(Kent Beck)이 Java에 포스팅하여 JUnit이 탄생했다. - [Wikipedia JUnit](https://en.wikipedia.org/wiki/JUnit)

---

### Assert.Class (테스트 검증)

##### assertEquals method in JUnit4
```java
static public void assertEquals(String message, Object expected, Object actual) {
    if (equalsRegardingNull(expected, actual)) {
        return;
    } else if (expected instanceof String && actual instanceof String) {
        String cleanMessage = message == null ? "" : message;
        throw new ComparisonFailure(cleanMessage, (String) expected,
                (String) actual);
    } else {
        failNotEquals(message, expected, actual);
    }
}
```

JUnit에서 Assert는 두 개의 값이 같다고 가정하여 테스트의 통과 여부를 진행한다.

 대부분 Assert 클래스에 포함되어 있는 메소드들은 `assert...(에러메시지(선택), 기댓값, 비교 값)`이라는 간단한 규칙을 따르고 있다.
첫 번째 매개변수에 에러 메시지를 포함할 수 있고 가정문이 기대하는 값과 다를 경우에 에러 메시지를 반환한다.



---

### 참고

> [https://www.360logica.com/blog/use-unit-testing/](https://www.360logica.com/blog/use-unit-testing/)<br/>
> [https://programmingwithmosh.com/csharp/unit-testing/](https://programmingwithmosh.com/csharp/unit-testing/) <br/>
> [https://dzone.com/articles/why-do-you-need-to-unit-test-if-you-have-a-qa-team](https://dzone.com/articles/why-do-you-need-to-unit-test-if-you-have-a-qa-team) <br/>
> [https://blog.ndepend.com/good-unit-test-5-must-haves/](https://blog.ndepend.com/good-unit-test-5-must-haves/) <br/>
> [https://www.guru99.com/unit-testing-guide.html](https://www.guru99.com/unit-testing-guide.html) <br/>
> [https://content.pivotal.io/blog/what-is-a-unit-test-the-answer-might-surprise-you](https://content.pivotal.io/blog/what-is-a-unit-test-the-answer-might-surprise-you) <br/>
> [https://dzone.com/articles/testing-in-micro-services-architecture](https://dzone.com/articles/testing-in-micro-services-architecture)<br/>
>[https://flylib.com/books/en/2.671.1.99/1/](https://flylib.com/books/en/2.671.1.99/1/)<br/>





