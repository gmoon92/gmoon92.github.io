---
layout: post
title: "TDD : Test Keywords"
tags: [TDD]
display: "false"
subtitle: "Basic software testing terminologies."
excerpt_separator: <!--more-->
sitemap:
changefreq: daily
priority: 1.0
---

<!--more-->

# Basic software testing terminologies.

---

### Unit Test

<img src="/md/img/TDD/UnitTest/unittest.png">
<em>Unit Test</em>

 단위 테스트는 코드를 테스트한 다음 자동화된 방식으로 테스트를 실행하는 코드 작성 방법이다.

일반적으로 단위 테스트는 객체 또는 모듈의 함수 자바에서는 클래스에 초점을 맞춰 작성하고 기능의 목적에 따라 각 부분으로 분리하여 테스트를 진행한다. 이 원칙은 세션 단위의 테스트는 개별 부분을 자동화된 검증을 하기 위함이다.

---

### Automated Test

자동화 테스트의 주요 이점은 오류를 예방하고 발견하는 것이다.

단위 테스트에 대한 오류는 테스트 된 클래스에서 일반적으로 발견된다. 이 오류는 개발 단계에서 발견되기 때문에 비용이 절감되는 효과가 나타나는데 개발 단계에서 발견된 오류는 비용을 절감하는 효과가 나타난다.
그 이유인즉슨 개발 중에 발견된 오류를 제거하는 것은 유지 보수 단계에서 같은 오류를 제거하는 것보다 훨씬 저렴하기 때문이다.

초기 오류 식별의 엄청난 비용 절감 가능성 외에도 단위 테스트를 통해 더 많은 이점을 얻을 수 있다. 
TFD 방식으로 생성된 단위 테스트는 개발 중에 재설계가 이루어지기 때문에 `Clean Architecture`의 발판이 된다.

> An error found during the coding or unit testing phase is cheaper by a factor of 10, compared to when it is found in the system test. This factor rises to 100 for errors found as late as during the software's productive use. - IBM [Subramaniam99]

이러한 효과는 다음의 그래프를 보면 쉽게 이해할 수 있다.

<img src="/md/img/TDD/UnitTest/automatedtest-graph.png">
<em>자동화 테스트와 수동 테스트의 비용 비교</em>

초기 비용은 수동 테스트보다 자동화 테스트가 높은데 이는 당연한 결과다. 하지만 테스트를 하는 횟수가 증가함에 따라 자동화 테스트 대비 수동 테스트의 비용이 기하급수적으로 증가함을 알 수 있다.
이러한 효과 이외에도  DevOps의 인식과 출현으로 인해 자동화 테스트의 중요성이 기하급수적으로 높아지면서 테스트는 전문 개발자와 아마추어 개발자를 구분하는 잣대 중 하나로 자리매김했다. 
절대적으로 TDD, BDD 또는 기타 테스트 방법론을 따르라는 것은 아니지만 최소한의 수준에서는 코드를 자동으로 테스트하도록 작성해야 한다. 이에 맞춰서 Java 개발자들은 지속적인 통합도구(CI)를 사용하여 빌드 타임 중에 자동으로 실행되는 단위 테스트 및 통합 테스트를 작성하고 있다.
 
---

### Test Framework

개발자는 단위 테스트를 작성하는 데 있어 QA보다 효율적으로 테스트할 수 있는 도구가 필요하다.

테스트 프레임워크는 더욱 효율적으로 테스트할 수 있도록 돕기 위해 고안된 방법과 도구가 결합 된 것으로 [JUnit](https://junit.org/junit5/), [Mockito](https://site.mockito.org/), [Selenium](https://www.seleniumhq.org/)등이 있다. 
테스트 프레임워크를 활용하면 다음과 같은 효과가 있다.

- 테스트 정확도 향상
- 테스트 효율성 향상
- 테스트 위험 감소
- 유지보수 비용 절감
- 최소한의 수동 개입
- 최대 테스트 커버리지 효과
- 코드의 재사용성

테스트 프레임워크에는 [6가지 유형](https://smartbear.com/learn/automated-testing/test-automation-frameworks/)이 있다. 각 유형은 자체 아키텍처와 각기 다른 장단점이 있고 이에 적합한 프레임워크를 선택하는 것이 중요하다.
 
---

### 테스트 문서화 (Test Script, Test Case, Test Scenarios)

개발자는 테스트 프레임워크를 활용하여 단위 테스트를 작성하려 한다. 이때 테스트 케이스를 작성하라고 요청을 받았다면 개발자가 가장 먼저 해야 할 일은 테스트의 문서화 하는 방법들에 대한 용어을 알아야 한다.

문서화 하는 방법에는 세 가지로 분류할 수 있다. 각각 다른 세부사항을 포함하고 있고 의미하는 바가 달라서 혼동하지 말고 사용해야 한다. 

#### Test Script

 테스트 스크립트는 테스트를 문서화하는 방법 중에 가장 상세한 방법이다.
 
일반적으로 테스트 스크립트는 테스트를 수행하는 데 필요한 모든 동작과 데이터를 한 줄씩 작성하는데 때문에 코드만 보면 프로그램에서 특정 동작을 수행하기 위해 어떤 버튼을 누르고 어떤 순서로 수행할지를 알 수 있다. 
테스트 스크립트에는 UI의 변경 사항을 확인하는 등 프로그램의 각 단계에서 예상되는 특정 결과가 포함하고 있다.

```java
@Test
public void userImgBtnClickTest() throws Exception {
	String userImgData = "yH5BAEAAAAALAAAAAABAAEAAAIBRAA7";
	selenium.open("/");
	selenium.type("query", "이미지 조회");
	selenium.click("//input[@type='image']");
	selenium.waitForPageToLoad("30000");
	assertEquals("이미지 테스트", userImgData, selenium.getImage());
}
```

다음 코드는 자동화 테스트 도구로 많이 활용하고 있는 Selenium으로 작성한 테스트 코드이다.
 
기능에 대한 설명을 생략했지만 누가봐도 버튼에 대한 테스트 코드라는 것을 알 수 있다.
이처럼 테스트 스크립트는 코드만으로 동작과 필요한 데이터에 대해 명확히 알 수 있어 오랜 시간이 지나 다시 테스트 스크립트를 봐야 하는 시기가 와도 담당자는 한눈에 이해할 수 있다는 장점이 있다. 
하지만 뷰가 바뀌는 순간 개발자는 테스트 스크립트를 재작성해야 한다는 단점이 있다.

### Test Case

 두 번째로 상세한 방법으론 테스트 케이스가 있다.

테스트 케이스는 소프트웨어 응용 프로그램의 기능이 제대로 작동하는지 즉 단위별 기능의 테스트 목록이다. 
프로세스에서 테스트를 취할 정확한 단계 나 사용되는 데이터를 자세히 설명하지 않고 기능에 대한 구체적인 todo-list를 작성한다.

> Test Case
> 1. 더하기
> 2. 빼기
> 3. 나누기
> 4. 곱하기

다음은 계산기에 대한 테스트 케이스이다. 하나의 기능이 제대로 동작하는지에 대한 todo-list인 셈이다.
테스트 케이스는 테스트 스크립트보다 자세한 세부사항을 알 수는 없다. 즉 입력과 출력만 알 수 있고 행위는 알지 못한다. 하지만 기능에 대한 테스트의 목록을 개발자는 알 수 있다.

```java
@Test
public void addTest(){
	int a = 1;
	int b = 2;
	int result = a + b;
	assertEquals("더하기 테스트", 3, reulst);
}
```


 




### Test Scenarios

테스트 시나리오는 테스트 중인 프로그램의 종단간 기능이 예상대로 작동하는지 확인하는 것이다. 프로그램을 사용할 때 사용자가 직면할 수 있는 상황에 대한 테스트를 뜻한다.

다음 예시를 보자.

회원가입 기능에서 이메일 인증은 반드시 필수인 상황이라고 가정하자.

|:-----------|:-----|
| 테스트 시나리오  | 사용자가 이메일 인증을 통과하는지 검증한다. |
| 테스트 케이스    | 1. 이메일 인증을 통과할때 통과 됐다는 메시지 반환<br/> 2. 이메일 인증이 안될 시 에러 메시지 반환 |



[https://en.wikipedia.org/wiki/Test_case](https://en.wikipedia.org/wiki/Test_case)	<br/>
[https://qacomplete.com/resources/articles/test-scripts-test-cases-test-scenarios/](https://qacomplete.com/resources/articles/test-scripts-test-cases-test-scenarios/)

[https://www.softwaretestingclass.com/what-is-difference-between-test-cases-vs-test-scenarios/](https://www.softwaretestingclass.com/what-is-difference-between-test-cases-vs-test-scenarios/)
[https://www.softwaretestinghelp.com/difference-between-test-plan-test-strategy-test-case-test-script-test-scenario-and-test-condition/](https://www.softwaretestinghelp.com/difference-between-test-plan-test-strategy-test-case-test-script-test-scenario-and-test-condition/)


---

### Assertion

[https://www.thoughtworks.com/insights/blog/test-assertions-how-do-they-work](https://www.thoughtworks.com/insights/blog/test-assertions-how-do-they-work)

[https://en.wikipedia.org/wiki/Test_assertion](https://en.wikipedia.org/wiki/Test_assertion)

---

### Test Coverage

테스트 커버리지 또는 코드 커버리지라고 불린다. 커버리지는 코드베이스에서 테스트 되지않는 부분을 찾는데 유용한 도구이다.

커버리지는 테스트 대상이 되는 실제 코드 중 어느 정도를 '커버'했는지, 즉 테스트 수행이 된 정도를 의미한다.
화이트 박스 테스트에서 코드 커버리지 기준을 활용하여 로직을 검증한다.
코드 커버리지의 경우 `Statement coverage(구문(문장) 커버리지)`, `Decision or Branch coverage(분기/결정 커버리지)`
, `Condition coverage(조건 커버리지)`,`MC/DC(변경 조건/결정 커버리지)`, `Multiple condition coverage(다중조건 커버리지)`
등  기준이 있다.

> [참고 Wiki - Code Coverage](https://en.wikipedia.org/wiki/Code_coverage)

> Code Coverage 기준 <br/>
> 1) Statement coverage(구문(문장) 커버리지)	 <br/>
> 2) Decision or Branch coverage(분기/결정 커버리지)	 <br/>
> 3) Condition coverage(조건 커버리지)	 <br/>

[https://martinfowler.com/bliki/TestCoverage.html](https://martinfowler.com/bliki/TestCoverage.html)

---


### 참고

> [https://smartbear.com/learn/automated-testing/test-automation-frameworks/](https://smartbear.com/learn/automated-testing/test-automation-frameworks/)
> [https://www.360logica.com/blog/use-unit-testing/](https://www.360logica.com/blog/use-unit-testing/)<br/>
> [https://programmingwithmosh.com/csharp/unit-testing/](https://programmingwithmosh.com/csharp/unit-testing/) <br/>
> [https://dzone.com/articles/why-do-you-need-to-unit-test-if-you-have-a-qa-team](https://dzone.com/articles/why-do-you-need-to-unit-test-if-you-have-a-qa-team) <br/>
> [https://blog.ndepend.com/good-unit-test-5-must-haves/](https://blog.ndepend.com/good-unit-test-5-must-haves/) <br/>
> [https://www.guru99.com/unit-testing-guide.html](https://www.guru99.com/unit-testing-guide.html) <br/>
> [https://content.pivotal.io/blog/what-is-a-unit-test-the-answer-might-surprise-you](https://content.pivotal.io/blog/what-is-a-unit-test-the-answer-might-surprise-you) <br/>
> [https://dzone.com/articles/testing-in-micro-services-architecture](https://dzone.com/articles/testing-in-micro-services-architecture)<br/>
>[https://flylib.com/books/en/2.671.1.99/1/](https://flylib.com/books/en/2.671.1.99/1/)<br/>


>[https://midojeong.github.io/2018/04/19/mocking-is-a-code-smell/](https://midojeong.github.io/2018/04/19/mocking-is-a-code-smell/)
>[https://lumiloves.github.io/2018/08/21/my-first-frontend-test-code-experience](https://lumiloves.github.io/2018/08/21/my-first-frontend-test-code-experience)



