---
layout: post
title: "TDD : TDD 개념 및 정의"
tags: [TDD]
subtitle: "Chapter1 선택이 아닌 필수 TDD(Test-driven Development)"
excerpt_separator: <!--more-->
display: "false"
sitemap:
changefreq: daily
priority: 1.0
---

<!--more-->

# Chapter1 선택이 아닌 필수 TDD(Test-driven Development)
 
---

### TDD?


> TDD = TFD(Test-First Development ) + Refactoring

TDD는 TFD와 리팩토링이 합쳐진 개발 방법론으로 소프트웨어 엔지니어인  켄트 벡(Kent Beck)에 의해 고안된 실제 코드를 작성하기 전 테스트 코드를 먼저 작성하여 개발하는 SW 개발 방법론이다.

> What is the primary goal of TDD?  One view is the goal of TDD is specification and not validation (Martin, Newkirk, and Kess 2003).  In other words, it’s one way to think through your requirements or design before your write your functional code (implying that TDD is both an important agile requirements and agile design technique). Another view is that TDD is a programming technique.  As Ron Jeffries likes to say, the goal of TDD is to write clean code that works. - [agiledata](http://agiledata.org/essays/tdd.html)

TDD는 디자인, 기술적 관점에 따라 기본적인 목표는 다르다.<br/>
첫 번째로 디자인 관점으로는 검증이 아닌 명세를 목표로 하고 있다. 즉 TDD 자체가 요구사항이고 디자인으로 생각한다.
기술적인 관점에서의 TDD의 목표는 작동하는 깨끗한 코드(`Clean code that works(중복이 없고 명확한 코드)`)를 작성하는 것이다.

TDD는 일반적인 개발 프로세스의 고질적인 문제점들을 고안해서 나온 개발 방법론이다. 그 때문에 TDD와 일반 개발 프로세스는 차이를 보면 우리가 왜 TDD를 해야 하는지 알 수 있다.

### 일반적인 개발 프로세스의 문제점들

<img src="/md/img/TDD/TDD1.png" height="200px">
<em>일반적인 개발 프로세스</em>
 
일반적인 개발 프로세스는 `설계(디자인) > 개발(코드 작성) > 테스트`하는 단계를 반복한다.

실제 실무에서 개발자 대부분이 `일반적인 개발 프로세스`를 따라가고 있다.
이러한 개발 방법론에 익숙해진 개발자가 보기엔 고질적인 문제점을 찾아 볼 수 없다. 어쩌면 개발에 나타나는 문제점들이 당연하다고 여기고 있을 수 있다.
하지만 `일반적인 개발 프로세스`에서의 문제점은 크게 세 가지로 나타난다.

> - **자체 버그 검출 능력 저하**
> - **소스코드의 품질 저하**
> - **자체 테스트 비용의 증가**

 이 문제점들이 발생되는 이유는 간단하다.
 어느 프로젝트든 초기 설계가 완벽하다고 말할 수 없기 때문이다. 고객의 요구사항 또는 디자인의 오류 등등 많은 외부 또는 내부 조건에 의해 재설계하여 점직전으로 완벽한 설계로 나아간다.<br/>
재설계로 인해 개발자는 코드를 삽입, 수정, 삭제하는 과정에서 쓰레기 코드가 남거나 코드가 중복처리 될 가능성이 크다. <br/>

결론적으로 이러한 코드들은 재사용이 어렵다.

더 나아가 코드가 복잡해지고 관리가 어려워져 유지보수를 어렵게 만든다.<br/>
이러한 코드는 작은 부분의 기능 수정에도 모든 부분을 테스트해야 하므로 전체적인 버그를 검출하기 어려움이 따라 `자체 버그 검출 능력`이 저하된다.
그 결과 어디서 버그가 발생할지 모르기 때문에 잘못된 코드도 고치지 않으려 하는 현상이 나타나고 이러한 현상은 `소스코드의 품질 저하`에 직결된다.
작은 수정에도 모든 기능을 다시 테스트해야 하는 문제가 발생하여 `자체 테스트 비용`이 증가 된다.


### 두려움을 관리하는 TDD

> Test-driven development (TDD) is a way of managing fear during programming. - Kent Beak

켄트 벡은 자신의 글에 'TDD는 개발에 있어 두려움을 관리해준다.'라고 명시했다. 여기서의 두려움이란 `일반적인 개발 프로세스`에서 나타난 여러 문제점을 뜻한다. 이러한 문제점들은 중복된 코드로부터 시작되는데 
`Clean code that works`를 추가하는 TDD는 이러한 중복된 코드로부터 발생하는 많은 문제점을 해결해준다.

무엇보다 TDD와 `일반적인 개발 프로세스`의 가장 큰 차이점은 테스트 코드를 작성한 뒤에 코드를 작성한다는 점이다.

<img src="/md/img/TDD/TDD2.png" height="200px">
<em>TDD 개발 프로세스</em>

TDD의 개발 프로세스는 다음과 같다. <br/>

`디자인(설계)` 단계에서 프로그래밍 목적을 반드시 미리 정의해야만 하고 또 무엇을 테스트해야 할지 미리 정의(테스트 케이스 작성)해야만 한다.

<img src="/md/img/TDD/architectureTFD.png" height="600px">
<em>TFD 순서도</em>

`테스트 케이스`가 작성된 후 `테스트 코드 작성` 단계에서 `TFD 개발 프로세스`와 같은 방식으로 테스트 코드를 작성한다. 테스트 코드를 작성하는 도중에 발생하는 예외 사항(버그, 수정사항)들은 `테스트 케이스`에 추가하고 설계를 개선한다. 이후 테스트가 통과된 코드를 `코드 작성` 단계에서 실제 코드를 작성함을 원칙으로 하고 있다.

이러한 반복적인 단계가 진행되면서 자연스럽게 코드의 버그는 줄어들고, 소스코드는 간결해진다.
또한, `테스트 케이스` 작성으로 인해 자연스럽게 설계가 개선됨으로 재설계 시간이 절감된다. <br/>

>TDD를 도입한 소프트웨어는 약 15~35% 정도의 개발시간 증가, 결함율(버그)은 약 40~90% 정도 줄어들었다. -  Microsoft, IBM


### Clean Code & RGR-Cycle

 TDD의 목표는 작동하는 깨끗한 코드(`Clean code that works`)를 작성하는 것이다. 하지만 'TDD는 어떻길래 중복코드가 없어지는 마술을 보이는 걸까?' 라는 의문이 생긴다.

TDD의 순서도를 보면 Clean Code가 되어가는 과정을 명확히 알 수 있다.

<img src="/md/img/TDD/architectureTDD.png" height="600px">
<em>TDD 순서도</em>

> 1) 테스트 코드를 작성한다.  <br/>
> 2) 테스트를 한다.		  <br/>
> 3) 테스트가 통과될 때까지 테스트 코드를 수정한다. <br/>
> 4) 테스트가 통과된 테스트 코드는 리펙토링을 한다. <br/>
> 5) 리펙토링한 코드를 테스트한다. <br/>
> 6) 리펙토링한 코드가 통과 될때까지 코드를 수정한다. <br/>
> 7) 테스트가 통과되면 테스트 케이스에 있는 다음 테스트 코드를 작성한다.

TDD는 테스트 후 리펙토링이라는 반복적인 과정을 통해 자연스럽게 코드는 명확해지고 깔끔해진다. 여기서 우리는 한가지 규칙적인 반복 패턴이 볼 수 있다.


> [If we pull back to the minute by minute scale we see the micro-cycle that experienced TDDers follow. The Red/Green/Refactor cycle. - Robert C. Martin](https://blog.cleancoder.com/uncle-bob/2014/12/17/TheCyclesOfTDD.html)

클린 코드 책의 저자로 유명한 로버트 C 마틴(엉클밥)은 다음과 같은 반복 패턴을 `RGR-Cycle`라고 명시했다.

#### <font style="color:red;">R</font><font style="color:green;">G</font>R-Cycle

<img src="/md/img/TDD/TDD4.png" height="200px">
<em>RGR-Cycle</em>

1. Red : 실패하는 `Test-Case` 만들기<br/>
2. Grean : 테스트가 통과하다록 생산 코드를 작성<br/>
3. Refactor : 실제 코드 리펙토링<br/>

`RGR` 주기는 소스코드의 리펙토링을 돕는것 뿐만 아니라 `TDD`의 궁극적인 목표인 `Clean code that works`를 지향한다. <br/>

 

`테스트 케이스 작성 및 수정 > 테스트 코드 작성  > 테스트를 통과한 테스트 코드만 코드 작성`하는 단계가 반복될수록 
코드의 버그는 줄어들고 코드는 간결해지고 명확해진다. 또한 `Test-Case` 작성으로 인해 자연스럽게 설계가 개선됨으로 재설계 시간이 절감된다. <br/>

결과적으로 `일반적인 개발 프로세스`에서의 복잡한 코드에 의해 나타난 문제점들이 개선된다.

즉 테스트를 중점으로 개발을 하고 있다는게 느껴진다.



#### 켄트백의 TDD 

> - Don’t write a line of new code unless you first have a failing automated.	<br/>
> - Eliminate duplication.

켄트 벡은 테스트 코드를 작성에 있어 대해 두 가지 원칙을 소개하고 있다.

처음 실패한 자동화 코드가 없으면 새로운 코드 행을 작성하지 마십시오.
중복을 제거하십시오.

---


#### Test Case 작성


---

### TDD의 원칙

---

### TDD의 이점

---

#### 밥 아저씨의 3가지 규칙


---

### 개발자에게 Test


---

### 테스트 주도 개발방법론 TDD의 등장

`TDD`는 켄트 벡(Kent Beak)에 의해 1999년에 XP라는 애자일 기반의 개발 방법론과 함께 등장했다.<br/>
왜, 무엇때문에 TDD 개발방법론이 등장했을까? <br/>
<br/>

하나의 소프트웨어는 수많은 기능을 하나로 합친 복합체이다.<br/>
소프트웨어는 사용자의 요구사항 또는 성능개선을 하기 위해 꾸준히 관리해야 한다. <br/>
하지만 소스코드를 관리하는 데 있어 여러 문제점이 있다.<br/>



이러한 가설은 Microsoft, IBM사의 조사 결과를 보면 입증할 수 있다.<br/>
>TDD를 도입한 소프트웨어는 약 15~35% 정도의 개발시간 증가, 결함율(버그)은 약 40~90% 정도 줄어들었다.

<br/>


---

### 3가지 규칙

`TDD`는 3가지 규칙으로 체계화되었다. <br/>

 1. 실패하는 테스트 코드를 작성할 때까지 실제 코드를 작성하지 않는다. <br/>
 2. 컴파일은 실패하지 않으면서 실행이 실패하는 정도로만 테스트 코드를 작성한다. <br/>
 3. 현재 실패하는 테스트 코드가 통과할 정도로만 실제 코드에 작성한다. <br/>

#### RGR-Cycle -  <font style="color:red;">Fail Test-Case</font> -> <font style="color:green;">Pase Test-Case</font> -> <font style="color:#bbbb05;">Refactor</font>

<img src="/md/img/TDD/TDD4.png" height="200px">
<em>RGR-Cycle</em>

1. Red : 실패하는 `Test-Case` 만들기<br/>
2. Grean : 테스트가 통과하다록 생산 코드를 작성<br/>
3. Refactor : 실제 코드 리펙토링<br/>

`RGR` 주기는 소스코드의 리펙토링을 돕는것 뿐만 아니라 `TDD`의 궁극적인 목표인 `Clean code that works`를 지향한다. <br/>

---

### FIRST - Test Case 작성하기

`TDD`는 테스트를 중점으로 개발하는 개발법이다. 때문에 `TDD`에서 `Test-Case` 작성은 가장 중요한 부분 중 하나이다.<br/>
`FISRT`는 2009년에 Brett Schuchert와 Tim Ottinger에 의해 `Test-Case` 코드 작성의 원칙을 제시하고 있다.<br/>

<img src="/md/img/TDD/TDD5.png" height="200px">
<em>F.I.R.S.T</em>

- #### Fast 테스트는 빨라야 한다.<br/>
	- 테스트가 느리면 자주 소스코드 검증을 하지 못한다. <br/>
 자주 검증하지 않은 소스코드는 그만큼 버그가 발생할 확률은 높아지고 소스코드의 품질 또한 낮아진다.<br/>

<br/>

- #### Independent 테스트는 독립적으로 작성한다.<br/>
	- 테스트가 서로에게 의존하면 하나가 실패할 때 나머지도 잇달아 실패하므로 원인을 진단하기 어려워진다.<br/>

<br/>

- #### Repeatable 테스트는 반복가능해야 된다.<br/>
	- 테스트는 실행중인 환경 / 인스턴스의 데이터에 의존해서는 안된다.<br/>
   테스트에 대한 결과는 언제 어디서나 동일한 결과를 나타내야된다.<br/>

<br/>

- #### Selef-Validating 테스트는 자체검증이 되어야 한다.<br/>
	- 테스트 검사가 통과하면 자동으로 감지할 수 있어야된다.<br/>

<br/>

- #### Timely 실제 코드가 있다면 테스트 코드도 있어야된다. <br/>
	- 모든 유스 케이스 시나리오를 다루고 100 % 적용 범위를 목표로 삼아야된다. <br/>
	- 테스트 주도 개발 (Test Driven Development, TDD)을 목표로 삼아 코드가 나중에 다시 팩할 필요가 없도록해야된다. <br/>

---

### 참고
[KentBeck TDD PDF](https://www.eecs.yorku.ca/course_archive/2003-04/W/3311/sectionM/case_studies/money/KentBeck_TDD_byexample.pdf)<br/>
[Agile Data](http://agiledata.org/essays/tdd.html)<br/>
[Empirical Software Engineering Group ](https://www.microsoft.com/en-us/research/group/empirical-software-engineering-group-ese/?from=http%3A%2F%2Fresearch.microsoft.com%2Fen-us%2Fgroups%2Fese%2Fnagappan_tdd.pdf)<br/>
[Robert C. Martin cleancoder](https://blog.cleancoder.com/uncle-bob/2014/12/17/TheCyclesOfTDD.html)<br/>
[F.I.R.S.T - Agile in a Flash](http://agileinaflash.blogspot.com/2009/02/first.html) <br/>
