---
layout: post
title: "OOP에 대해 말해주세요"
tags: [OO, OOP, Class-based programming, Prototype-based programming]
categories: [OO]
subtitle: "OOP에 대한 고찰"
feature-img: "md/img/thumbnail/oop.png"
thumbnail: "md/img/thumbnail/oop.png"
excerpt_separator: <!--more-->
sitemap:
display: "false"
changefreq: daily
priority: 1.0
---

<!--more-->

# OOP에 대한 고찰

---

OOP 혹은 객체지향 프로그래밍이라는 단어는 개발자라면 수도 없이 들었던 단어이다. 특히 신입 개발자 대상으로 자주 나오는 질문 중 하나로써 개발자가 OOP라는 개념에 대해 얼마만큼 인지하고 있는지에 대해 중요시 여겨지는 듯하다.

 물론 프로그래밍의 패러다임은 많이 존재한다. 하지만 여전히 대부분의 대형 프로젝트에선 OOP를 사용하며 개발을 하고 있다. 이는 OOP가 개발의 효과적인 프로그래밍이라는 것을 입증하는 동시에 하나의 대표적인 프로그래밍의 패러다임으로써 자리매김했다는 뜻이기도 한다.

하지만 'OOP가 뭔가요?' 혹은 'OOP를 이해하고 개발을 하나요?'라는 물음에 제대로 설명을 할 수 있는 개발자가 몇 명이나 되는지 의문이다. 본 포스팅에선 OOP의 배경부터 전반적인 부분을 상세히 다룰 예정이다. 이번 포스팅은 다음과 같은 학습 목표가 있다.

### 학습 목표

- OOP의 배경을 이해한다.
- OOP의 이점을 이해한다.
- 무엇보다 누군가 OOP에 대해 물어본다면 자신있게 대답할 수 있어야 한다.

---

### OOP

OOP는 Object-Oriented Programming의 약자로 흔히 객체지향 프로그래밍이라 불린다. 이 객체지향 프로그래밍은 컴퓨터 프로그래밍의 하나의 패러다임으로써, 실제 세계에 기반을 둔 모델을 모듈화하기 위해 추상화를 사용하는 프로그래밍 패러다임이다.

이 패러다임은 논리적인 수행을 중심으로 개발하였던 전통적인 소프트웨어의 개발 방식을 완전히 새로운 시각으로 바라본 혁명적인 개념으로써 동작보다는 객체, 논리보다는 자료를 바탕으로 구성한다. 즉 논리적인 데이터를 실제 프로그램에서 다뤄질 물리적인 데이터로 변환하고, 이 물리적인 데이터를 통상 객체라 칭해 이 객체를 중심으로 개발하는 방식을 지향한다.

그렇다면 왜 우리는 객체를 중심으로 개발해야 하고 현재 많은 개발자가 객체 지향적으로 설계된 프로그램을 개발하고 있을까?

### OOP의 등장배경

이 의문의 답은 두 가지 시각으로 살펴보려 한다.

 - 1. 프로그래밍 언어의 역사
 - 2. 전통적인 SW 개발방식


#### 1. 언어의 역사의 관점

언어가 탄생하고 그 언어를 다루는 프로그래밍의 패러다임이 나오듯, 프로그래밍 언어의 역사를 보며 의문에 대한 답을 찾아보려 한다.



 CPU가 이해할 수 있는 기계어(저급언어)를 사용했다. 기계어는 0과 1로만 이루어져 있었기 때문에, 프로그래밍하기가 어려웠고, 유지보수는 불가능에 가까웠다. 그리고 CPU가 바뀌면 처음부터 다시 짜야한다. (CPU에 따라 연산방법이 달랐고, 이해하는 언어도 달랐기 때문이다.

② 0과1로 이루어진 불편함을 해결하기 위해 나온것이 어셈블리어(저급언어)였다. 기계어의 문법은 그대로 유지하면서 최소한의 알파벳으로 치환한 언어였다. 어셈블러라고 하는 치환기가 단어들을 0과 1로 치환하여 CPU가 이해하도록 하였다.

③ 여전히 CPU가 바뀌면 호환성이 낮고, 여전히 언어의 불편함이 있고, 흐름제어문(for, if, while 등)이 없어 오직 goto문으로만 이루어져 있어 스파게티소스가 되었다. 때문에 흐름제어문과, 함수의 개념을 추가한 구조적 언어(고급언어)가 개발되었다.

사람이 쓰는 언어인 자연어와 비슷하게 만들고, 컴파일러에게 번역하여 CPU에게 알아듣도록 하였다.

※ 스파게티소스는 goto문으로 인해 발생하는데, 프로그램은 문장이 위에서 아래로 실행이 된다. 쭉 실행이 되다가 갑자가 2번째 줄로 가라는 goto문을 만나면 2번째 줄로 이동한다. 2번째 줄부터 다시 읽어 내려오다가 갑자기 2000째 줄로 이동하라고 하면 다시 2000번 째 줄로 이동한다.

 이런식으로 규칙성이 없이 계속 이동하게 되면 흐름이 얽힌 실타래처럼 꼬이는데 이것이 스파게티와 같다고해서 스파게티소스라고 한다. 그런 스파게티소스는 프로그래머가 유지 보수하기가 상당히 힘들어 진다.

④ 하지만 구조적 언어는 이식성이 낮은 불편함이 있었다. 그 문제를 해결하기위해 객체의 개념을 추가하고 기존에 있던 함수와 흐름제어문의 개념을 그대로 도입한 것이 객체지향언어(고급언어)이다.

#### 2. 전통적인 SW 개발방식

두 번째는 기존의 전통적인 소프트웨어의 개발 방식에서 찾을 수 있다.

기존의 전통적인 소프트웨어는 논리적인 수행 즉, 입력을 받아 처리한 다음, 결과를 내는 것이라는 생각이 지배적이었다. 또한 프로그래밍한다는 것은 '어떻게 자료를 정의할까' 보다는 어떻게 논리를 써나가는 것인가로 간주하였다.

하지만 논리를 중점으로 개발된 소프트웨어는 내부 모듈의 상호 간 높은 결합도를 형성하여 모듈의 재사용이 어려웠다. 결과적으로 프로젝트 버퍼(Project buffer)가 대부분 개발 기간으로 소진되었고, 종종 기능 일부분을 수정하기 위해선 전체적인 설계를 수정해야 하는 경우가 발생했다. 이러한 기존의 전통적인 개발 방식의 회고들은 고찰하는 계기가 되었다.

이후에 소프트웨어에서 논리보다는 오히려 다루고자 하는 객체가 중요하다는 결론을 다다르게 되었고 이를 바탕으로 OOP라는 새로운 프로그래밍의 패러다임이 등장했다.

#### 자료 추상화(Data Abstraction)

OOP를 실현하기 위해 가장 먼저 해야 할 단계는 자료 추상화이다. 자료의 추상화란 하나의 논리를 독립적인 모듈로 보기 위해 구체적인 자료형 혹은 구조를 만드는 일련의 과정을 뜻한다.

이 과정은 프로그램에서 다뤄질 물리적인 데이터를 만들기 위해 논리적인 데이터들의 상호 간의 어떠한 연관성이 있는지 식별하고 관계를 맺는 작업을 한다. 이러한 작업을 추상화라 하고 흔히 데이터 모델링이라는 작업이 이와 같다.

일단 모든 논리적인 데이터를 물리적인 데이터로 추상화했다면, 이 물리적 데이터는 객체 클래스로 일반화하고 이 객체가 담고 있는 속성과 행위를 데이터의 종류와 그것을 다룰 수 있는 모든 논리 순서로 인스턴스 한다.
 
인스턴스한 데이터 종류와 논리순서는 변수와 메소드라 부르고 이러한 클래스의 실제 인스턴스 하나를 상황에 따라 '객체' 또는 '클래스 활성체'라 한다. 객체 또는 활성체는 실제 프로그램에서 다뤄질 데이터로써 정의한한다. 일반적으로 메소드는 수행할 명령어를 규정하고, 변수는 객체와 관련한 데이터를 규정한다.

### OOP의 이점

OOP는 모든 객체를 모듈화하여 유연하고 유지 보수성이 높은 프로그래밍을 할 수 있도록 의도되었다. 일반적으로 이 모듈을 클래스 기반의 언어에선 클래스라 부르고 결론적으로 클래스를 재사용한다는 원초적인 원칙을 통해 코드를 간단하고, 명료하고, 효율적으로 관리할 수 있게 된다.

#### Own과 Manipulation의 차이점

또한, 절차적 프로그래밍과 OOP를 비교하며 그로인해 오는 OOP의 이점에 대해 이야기 해보려 한다.

 절차적인 프로그래밍과 OOP의 데이터의 Own(소유권)과 Manipulation(조작)에 대한 차이점으로 부터 오는 이점들이 있다.

이러한 차이점은 언제 어떻게 데이터가 생성되고 전달되고 사용되고 소멸하는가의 차이가 OOP라는 개념을 만들어냈다.

절차적인 설계는 어떤 기능을 하는 함수는 누군가가 호출해주는 전통적인 제어의 흐름을 형성하고 있다. 자연스레 기능은 수직관계가 형성되는 동시에 기능에 필요한 데이터는 위에서 아래로 전달되었다.

하지만 OOP는 자료의 소유 , 생성이 각 객체에 의해서 알아서 되고 추상적 설계를 통해서 제어의 역전을 만들어내지 어떤 기능이 실행될 때 실제 실행될 코드가 나중에 결정되도록 하는거지

그러면 순차적으로 실행되는 코드의 위에서 아래의코드로 어떤 값을 넘기거나 코드의 실행순서를 결정하지 않아도 되고  각 모듈/클래스 별로 정의된 기능이 실행되는거지

---

절차적인 언어와 OOP의 차이점은 데이터의 Own(소유)과 Manipulation(조작) 에 대한 개념이야. 언제 어떻게 데이터가 생성되고 전달되고 사용되고 소멸하는가의 차이가 OOP라는 개념을 만들어낸거야

 무슨 말이냐면 어떤 기능을 하는 함수는 누군가가 호출해주어야 하고 제어의 흐름이 전통적이게 되는거지 그러면서 기능에 필요한 데이터를 자연스럽게 위에서 아래로 전달되는거야

하지만 OOP는 자료의 소유 , 생성이 각 객체에 의해서 알아서 되고 추상적 설계를 통해서 제어의 역전을 만들어내지 어떤 기능이 실행될 때 실제 실행될 코드가 나중에 결정되도록 하는거지

그러면 순차적으로 실행되는 코드의 위에서 아래의코드로 어떤 값을 넘기거나 코드의 실행순서를 결정하지 않아도 되고  각 모듈/클래스 별로 정의된 기능이 실행되는거지


 (스승)  Pascal, C 이런 언어는 절차적 언어야 가장 단적인 예를 들자면 어떤 기능을 하는 함수를 만들었다면 그 함수에 필요하 입력은 반드시 전역이나 전달인자로 전해주어야 하지

 무슨 말이냐면 어떤 기능을 하는 함수는 누군가가 호출해주어야 하고 제어의 흐름이 전통적이게 되는거지 그러면서 기능에 필요한 데이터를 자연스럽게 위에서 아래로 전달되는거야

하지만 OOP는 자료의 소유 , 생성이 각 객체에 의해서 알아서 되고 추상적 설계를 통해서 제어의 역전을 만들어내지 어떤 기능이 실행될 때 실제 실행될 코드가 나중에 결정되도록 하는거지

그러면 순차적으로 실행되는 코드의 위에서 아래의코드로 어떤 값을 넘기거나 코드의 실행순서를 결정하지 않아도 되고  각 모듈/클래스 별로 정의된 기능이 실행되는거지

---


### 객체지향의 4가지 특징 - 캡추다상정

#### Encapsulation(캡슐화)

#### Abstract(추상화)

---

유념해야할 부분은 추상화와 자료의추상화는 다른개념이야

 간단히 예를 들자면 추상화라는건 클래스의 설계를 위해서 상속관계/구현 등의 구조를 관계가 느슨하도록 만들면서도 서로 강하게 연결되도록 구조화시키는데 쓰이는 개념이지

 그렇다면 클래스 기반의 언어에서는 추상화를 쓸 수 있다는거네요? 자료의 추상화를 자료를 은닉시키고 상속관계하에서 접근을 제한/허용하는 등의 접근체계를 만드는 개념이지 추상화는 설계의 개념이야

꼭 클래스 기반언어에서만 쓰이는게 아니지  C언어는 추상화 못하나?

굳이 의미를 부여하자면 Module 기반 언어지

---

#### Polymorphism(다형성)

#### Inheritance(상속성, 재사용)

#### Information hiding(정보 은닉)


### 객체지향의 5원칙

#### SRP : 단일 책임 원칙
#### OCP : 개방-폐쇄 원칙
#### LSP : 리스코프 치환 원칙
#### ISP : 인터페이스 분리 원칙
#### DIP : 의존성 역전 원칙


### 마무리



앞서 설명을 통해 OOP라는 개념을 처음 알게 되었을진 몰라도 우리는 능숙하게 OOP를 하며 개발하고 있다. 흔히 우리가 사용했던 JAVA가 바로 대표적인 객체지향 언어로 클래스, 메소드, 변수를 사용하며 개발하기 때문이다.


---

### 참고


[나무위키 - 객체지향의 5대 원칙](https://namu.wiki/w/%EA%B0%9D%EC%B2%B4%20%EC%A7%80%ED%96%A5%20%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/%EC%9B%90%EC%B9%99)

 [OOP 객체지향 프로그래밍](http://www.terms.co.kr/OOP.htm)

 [[Java] OOP(객체지향 프로그래밍)의 특징](https://gmlwjd9405.github.io/2018/07/05/oop-features.html)


 [OOP 탄생배경](https://m.blog.naver.com/PostView.nhn?blogId=ghen4268&logNo=110184188778&proxyReferer=https%3A%2F%2Fwww.google.com%2F)

 [OOP 등장 배경, 기본 개념, 특징](https://m.blog.naver.com/PostView.nhn?blogId=mhg1186&logNo=220661553978&proxyReferer=https%3A%2F%2Fwww.google.com%2F)

 [버퍼](http://www.jidum.com/jidums/view.do?jidumId=391)
