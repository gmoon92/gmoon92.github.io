---
layout: post
title: "TDD : TDD 개념 및 정의"
tags: [TDD]
subtitle: "Chapter1 선택이 아닌 필수 TDD(Test-driven Development)"
excerpt_separator: <!--more-->
display: false
sitemap:
changefreq: daily
priority: 1.0
---

<!--more-->

# Chapter1 선택이 아닌 필수 TDD(Test-driven Development)
 
---

### TDD?

TDD는 소프트웨어 엔지니어인  켄트 벡(Kent Beck)에 의해 고안된 실제 코드를 작성하기 전 테스트 코드를 먼저 작성하여 개발하는 SW 개발 방법론이다.
많은 개발자가 TDD를 테스트 기술로 확대 해석하는 경우가 많다. TDD는  전체적인 디자인, 개발 및 테스트 프로세스의 개념이라는 점을 유의하자.

TDD는 일반적인 개발 프로세스의 고질적인 문제점들을 고안해서 나온 개발 방법론이다. 그 때문에 TDD와 일반 개발 프로세스는 차이를 보면 우리가 왜 TDD를 해야 하는지 알 수 있다.

### 일반적인 개발 프로세스의 문제점들

<img src="/md/img/TDD/TDD1.png" height="200px">
<em>일반적인 개발 프로세스</em>
 
일반적인 개발 프로세스는 `설계(디자인) > 개발(코드 작성) > 테스트`하는 단계를 반복한다.

실제 실무에서 개발자 대부분이 `일반적인 개발 프로세스`를 따라가고 있다.
이러한 개발 방법론에 익숙해진 개발자가 보기엔 고질적인 문제점을 찾아 볼 수 없다. 어쩌면 개발에 나타나는 문제점들이 당연하다고 여기고 있을 수 있다.
하지만 `일반적인 개발 프로세스`에서의 문제점은 크게 세 가지로 나타난다.

> - **자체 버그 검출 능력 저하**
> - **소스코드의 품질 저하**
> - **자체 테스트 비용의 증가**

 이 문제점들이 발생되는 이유는 간단하다.
 어느 프로젝트든 초기 설계가 완벽하다고 말할 수 없기 때문이다. 고객의 요구사항 또는 디자인의 오류 등등 많은 외부 또는 내부 조건에 의해 재설계하여 점직전으로 완벽한 설계로 나아간다.<br/>
재설계로 인해 개발자는 코드를 삽입, 수정, 삭제하는 과정에서 쓰레기 코드가 남거나 코드가 중복처리 될 가능성이 크다. <br/>

결론적으로 이러한 코드들은 재사용이 어렵다.

더 나아가 코드가 복잡해지고 관리가 어려워져 유지보수를 어렵게 만든다.<br/>
이러한 코드는 작은 부분의 기능 수정에도 모든 부분을 테스트해야 하므로 전체적인 버그를 검출하기 어려움이 따라 `자체 버그 검출 능력`이 저하된다.
그 결과 어디서 버그가 발생할지 모르기 때문에 잘못된 코드도 고치지 않으려 하는 현상이 나타나고 이러한 현상은 `소스코드의 품질 저하`에 직결된다.
작은 수정에도 모든 기능을 다시 테스트해야 하는 문제가 발생하여 `자체 테스트 비용`이 증가 된다.


### 두려움을 관리하는 TDD

> Test-driven development (TDD) is a way of managing fear during programming. - by Kent Beak

켄트 벡은 자신의 글에 'TDD는 개발에 있어 두려움을 관리해준다.'라고 명시했다. 여기서의 두려움이란 `일반적인 개발 프로세스`에서 나타난 여러 문제점을 뜻한다. 이러한 문제점들의 중복된 코드로부터 시작되는데 
TDD가 `Clean code that works`를 추구하는 이유이다.

<img src="/md/img/TDD/TDD2.png" height="200px">
<em>TDD 개발 프로세스</em>

 TDD와 `일반적인 개발 프로세스`의 가장 큰 차이점 달리 테스트 코드를 작성한 뒤에 코드를 작성하는 점이다. <br/>
테스트 코드의 작성에 앞서 `디자인(설계)` 단계에서 프로그래밍 목적을 반드시 미리 정의해야만 하고 또 무엇을 테스트해야 할지 미리 정의(테스트 케이스 작성)해야만 한다.
테스트 케이스가 작성되면 `테스트 코드 작성` 단계에서 테스트 코드를 작성한다. 이후 테스트가 통과된 코드만이 `코드 작성` 단계에서 실제 코드를 작성함을 원칙으로 하고 있다.

TDD는 테스트로부터 시작된다고 말해도 과언이 아니다.

### Clean Code

> TDD = TFD(Test-First Development ) + Refactoring

TDD는 TFD와 리팩토링이 합쳐진 개발 방법론이다. <br/> 
앞서 설명은 테스트를 먼저 개발하는 TFD 관점으로 'TDD는 어떻길래 중복코드가 없어지는 마술을 보이는 걸까?' 라는 의문이 생긴다.

테스트를 중점으로 하는 것이 맞지만 궁극적인 목적인 클린코드

클린코드를 지향하는 TDD를 알려면 를 봐야된다.


여기서 TFD를 살펴보면 TDD가 추구하는 `Clean code that works`을 알 수 있다.




`테스트 케이스 작성 및 수정 > 테스트 코드 작성  > 테스트를 통과한 테스트 코드만 코드 작성`하는 단계가 반복될수록 
코드의 버그는 줄어들고 코드는 간결해지고 명확해진다. 또한 `Test-Case` 작성으로 인해 자연스럽게 설계가 개선됨으로 재설계 시간이 절감된다. <br/>

결과적으로 `일반적인 개발 프로세스`에서의 복잡한 코드에 의해 나타난 문제점들이 개선된다.

즉 테스트를 중점으로 개발을 하고 있다는게 느껴진다.


#### GOAL

#### 

> - Don’t write a line of new code unless you first have a failing automated.	<br/>
> - Eliminate duplication.

코딩, 테스트, 디자인(리펙토링 형태)의 세가지 활동이 밀접하게 결합된 개발 방법을 뜻한다.

켄트 벡은 TDD에 테스트 코드를 작성에 있어 대해 두 가지 원칙을 소개하고 있다.
첫번째 실패 되는 테스트 코드를 작성되지 않으면 진행하지 말고 테스트가 통과되면 
일반적인 개발 프로세스의 틀을 깨고 있다.





#### 켄트백의 TDD
· Don’t write a line of new code unless you first have a failing automated test. <br/>
· Eliminate duplication <br/>

---

### TDD의 절차

#### RGR 주기
#### cleancode

#### Test Case 작성


---

### TDD의 원칙

---

### TDD의 이점

---

#### 밥 아저씨의 3가지 규칙


---

### 개발자에게 Test


---

### 테스트 주도 개발방법론 TDD의 등장

`TDD`는 켄트 벡(Kent Beak)에 의해 1999년에 XP라는 애자일 기반의 개발 방법론과 함께 등장했다.<br/>
왜, 무엇때문에 TDD 개발방법론이 등장했을까? <br/>
<br/>

하나의 소프트웨어는 수많은 기능을 하나로 합친 복합체이다.<br/>
소프트웨어는 사용자의 요구사항 또는 성능개선을 하기 위해 꾸준히 관리해야 한다. <br/>
하지만 소스코드를 관리하는 데 있어 여러 문제점이 있다.<br/>



이러한 가설은 Microsoft, IBM사의 조사 결과를 보면 입증할 수 있다.<br/>
>TDD를 도입한 소프트웨어는 약 15~35% 정도의 개발시간 증가, 결함율(버그)은 약 40~90% 정도 줄어들었다.

<br/>

---

### Clean code

TDD는 작은 단위의 `Test-Case`를 작성하고 이를 통과하는 `Test-Case`를 코드에 추가하는 단계를 반복한다.<br/>
이러한 방법은 TDD가 `Clean code that works`를 추구하기 때문이다.<br/>

`Clean code that works`는 단순한 의미가 아니라 중복이 없고 명확한 코드를 뜻한다.<br/>
`TDD`을 활용하여 `Test-Case`를 작성하면 `Test-Case` 소스코드는 명확해지고 자연스레 적용되는 실제 소스코드 또한 minimal해진다.<br/>
당연히 실제 소스코드가 minimal해지면 유지보수가 쉬워진다.<br/>
<br/>
`Clean code that works` 원칙은 다음과 같다.<br/>
- 오직 자동화된 테스트가 실패할 경우에만 새로운 코드를 작성한다.<br/>
- 중복을 제거한다.<br/>

---

### 3가지 규칙

`TDD`는 3가지 규칙으로 체계화되었다. <br/>

 1. 실패하는 테스트 코드를 작성할 때까지 실제 코드를 작성하지 않는다. <br/>
 2. 컴파일은 실패하지 않으면서 실행이 실패하는 정도로만 테스트 코드를 작성한다. <br/>
 3. 현재 실패하는 테스트 코드가 통과할 정도로만 실제 코드에 작성한다. <br/>

이러한 규칙들은 오랜 시간 동안 체계적으로 정의되면서 `TDD`를 대표하는 규칙들로 정해졌다.<br/>

이후 켄트 벡(Kent Beck)은 `TDD`를 적용할때 `RGR` 주기를 발견한다.<br/>

#### RGR-Cycle -  <font style="color:red;">Fail Test-Case</font> -> <font style="color:green;">Pase Test-Case</font> -> <font style="color:#bbbb05;">Refactor</font>

<img src="/md/img/TDD/TDD4.png" height="200px">
<em>RGR-Cycle</em>

1. Red : 실패하는 `Test-Case` 만들기<br/>
2. Grean : 테스트가 통과하다록 생산 코드를 작성<br/>
3. Refactor : 실제 코드 리펙토링<br/>

`RGR` 주기는 소스코드의 리펙토링을 돕는것 뿐만 아니라 `TDD`의 궁극적인 목표인 `Clean code that works`를 지향한다. <br/>

---

### FIRST - Test Case 작성하기

`TDD`는 테스트를 중점으로 개발하는 개발법이다. 때문에 `TDD`에서 `Test-Case` 작성은 가장 중요한 부분 중 하나이다.<br/>
`FISRT`는 2009년에 Brett Schuchert와 Tim Ottinger에 의해 `Test-Case` 코드 작성의 원칙을 제시하고 있다.<br/>

<img src="/md/img/TDD/TDD5.png" height="200px">
<em>F.I.R.S.T</em>

- #### Fast 테스트는 빨라야 한다.<br/>
	- 테스트가 느리면 자주 소스코드 검증을 하지 못한다. <br/>
 자주 검증하지 않은 소스코드는 그만큼 버그가 발생할 확률은 높아지고 소스코드의 품질 또한 낮아진다.<br/>

<br/>

- #### Independent 테스트는 독립적으로 작성한다.<br/>
	- 테스트가 서로에게 의존하면 하나가 실패할 때 나머지도 잇달아 실패하므로 원인을 진단하기 어려워진다.<br/>

<br/>

- #### Repeatable 테스트는 반복가능해야 된다.<br/>
	- 테스트는 실행중인 환경 / 인스턴스의 데이터에 의존해서는 안된다.<br/>
   테스트에 대한 결과는 언제 어디서나 동일한 결과를 나타내야된다.<br/>

<br/>

- #### Selef-Validating 테스트는 자체검증이 되어야 한다.<br/>
	- 테스트 검사가 통과하면 자동으로 감지할 수 있어야된다.<br/>

<br/>

- #### Timely 실제 코드가 있다면 테스트 코드도 있어야된다. <br/>
	- 모든 유스 케이스 시나리오를 다루고 100 % 적용 범위를 목표로 삼아야된다. <br/>
	- 테스트 주도 개발 (Test Driven Development, TDD)을 목표로 삼아 코드가 나중에 다시 팩할 필요가 없도록해야된다. <br/>

---

### 참고
[KentBeck TDD PDF](https://www.eecs.yorku.ca/course_archive/2003-04/W/3311/sectionM/case_studies/money/KentBeck_TDD_byexample.pdf)<br/>
[Agile Data](http://agiledata.org/essays/tdd.html)<br/>
[Empirical Software Engineering Group ](https://www.microsoft.com/en-us/research/group/empirical-software-engineering-group-ese/?from=http%3A%2F%2Fresearch.microsoft.com%2Fen-us%2Fgroups%2Fese%2Fnagappan_tdd.pdf)<br/>
[RGR-Cycle](https://blog.cleancoder.com/uncle-bob/2014/12/17/TheCyclesOfTDD.html)<br/>
[F.I.R.S.T - Agile in a Flash](http://agileinaflash.blogspot.com/2009/02/first.html) <br/>
