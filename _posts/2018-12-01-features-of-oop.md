---
layout: post
title: "OOP의 특징"
tags: [OO, OOP-features, OOP-Principles]
categories: [OO]
subtitle: "OOP를 하면서, 무심코 지나쳤던 OOP의 특징들"
feature-img: "md/img/thumbnail/oop.png"
thumbnail: "md/img/thumbnail/oop.png"
excerpt_separator: <!--more-->
sitemap:
display: "false"
changefreq: daily
priority: 1.0
---

<!--more-->

# OOP를 하면서, 무심코 지나쳤던 OOP의 특징들

---

### 들어가기전

본 포스팅은 OOP를 하면서 무심코 지나쳤던 OOP의 특징에 대해 알아보려 한다. 흔히 "캡추다산정"이라 불리는 캡슐화, 추상화, 다형성, 상속성, 정보 은닉의 개념과 실제 어디서 활용했었는지에 대해 작성할 예정이다. 객체지향, OOP의 개념적인 부분은 아래 링크를 참고하기 바란다.

>[1. 객체지향에 대해](https://gmun.github.io/oo/2018/11/12/oo.html) <br/>
>[2. OOP에 대한 고찰](https://gmun.github.io/oo/2018/11/20/oop.html) <br/>

### 학습 목표

1. 캡슐화에 대한 이해
2. 추상화에 대한 이해
3. 다형성에 대한 이해
4. 상속성에 대한 이해
5. 정보 은닉에 대한 이해

---

### Encapsulation(캡슐화) - 묶고, 숨기다.

![img](/md/img/oop/encapsulation.png "Information hiding")

캡슐화의 정의는 언어 측면과 기술 측면으로 정의할 수 있다.

- 언어 측면 : 객체의 속성(data fields)과 행위(methods)를 하나로 묶어져 있는 언어적 구조
- 기술 측면 : 일부 구현 내용을 외부에 감추어 은닉

이처럼 두 가지 측면은 다른 의미를 다루고 있지만, **모듈의 재사용성 향상**이라는 하나의 방향성을 띄고 있다.

<img src="/md/img/oop/encapsulation1.png" style="max-height:none">

먼저 언어적 측면으로는 흔히 클래스를 정의하고 내부에 데이터와 메소드를 정의하고, 정의된 클래스를 프로그램의 독립적인 단일 단위로 바라본다는 개념이다. 이는 클래스 기반 언어의 언어 구조 특징으로, 이를 캡슐화라 정의한다.

 하지만 단순히 클래스 기반 언어의 구조 특징을 캡슐화라 정의할 수 없다. 캡슐화란 클래스 기반 언어의 구조적인 개념에 국한되어있지 않고, 다른 언어에서도 캡슐화란 개념이 나오기 때문이다. 이러한 이유는 캡슐화란 일부 구현 기능의 은닉 정도를 제어한다는 측면으로 바라보는 개념이 있기 때문이다.

#### 정보은닉 그리고 모듈화

이 개념을 정보 은닉(Data hiding)이라 하는데, 캡슐화에선 이 개념을 통해 기능의 단순화라는 방향성에 초점을 두고 있다. 언어적 측면에서는 접근 제한자를 통해 이 메커니즘을 구현할 수 있다.

<img src="/md/img/oop/encapsulation2.png" style="max-height:none">

 다음 그림을 보면 `Alam` 클래스 내부에 일부 데이터들을 접근 제한자를 지정하여 외부로부터 직접적인 데이터 접근을 제한하고 있다. 이처럼 클래스 내부에서 실제적으로 데이터를 조작하는 메소드 또는 핵심 데이터를 은닉하고, 직접 호출하지 않는 대신, 필요에 따라 사용할 수 있는 기능을 외부에 공개한다.

<img src="/md/img/oop/encapsulation3.png" style="max-height:none">

 결과적으로 개발자는 필요한 메소드만 호출하여 데이터를 얻을 수 있고, 동시에 다른 기능, 데이터에 영향을 미치지 않고 변경될 수 있다. 무엇보다 데이터를 조작하기 위한 세부적인 구현 기능을 외부의 접근으로부터 제한하고 클래스 내부 안에서 동작하기 때문에, 객체라는 단위를 보다 하나의 독립적인 단위로 바라보고 결과적으로 객체의 기능을 재사용성이 향상된다.

 정리하자면 캡슐화 개념은 독립적인 모듈화를 기본 메커니즘을 따르고, 동시에 객체의 기능을 적용하는 과정에 더 쉽게 접근하기 위해 일부 데이터 접근을 제한하는 데이터 은닉이라는 개념을 사용한다.

흔히 캡슐화와 정보 은닉(Information Hiding)에 대해서 같은 개념으로 정의하는데, 캡슐화는 모듈화(modularity)의 중점으로 둔 개념이고, 정보 은닉은 직접적인 데이터 접근에 대한 개념을 중점으로 둔 개념이다. 따라서 캡슐화의 독립적인 모듈화를 실현하기 위해 정보 은닉을 사용하기 때문에 잘 된 캡슐화엔 정보은닉의 개념이 포함하고 있다.

### Information hiding(정보 은닉) - 보호하다.

![img](/md/img/oop/information-hiding.png "Information hiding")

 정보 은닉은 외부에서 데이터 접근을 제한한다는 개념이다.

 언어적 측면에서 정보 은닉은 접근 제한자를 통해 은닉의 정도를 구현할 수 있다. 따라서 클래스의 데이터 또는 메소드에 접근 제한자를 기술하여 외부에서 데이터 접근을 제한할 수 있다.

<img src="/md/img/oop/access-limiter.png" style="max-height:none">

- private : 자기 클래스 내부의 메서드에서만 접근 허용
- default : 같은 패키지에 있는 객체만 접근 허용
- protected : 같은 패키지에 있는 객체 또는 상속받은 자식 클래스에서 접근 허용
- public : 모든 접근을 허용

프로그래밍에 있어 이러한 접근 제한자들은 클래스 외부로부터 제한된 접근 권한을 제공하며 원하지 않는 외부의 접근에 대해 내부를 보호하는 작용을 한다. 이렇게 함으로써 이들 부분이 프로그램의 다른 부분들에 영향을 미치지 않고 변경될 수 있다.

 예를 들면, 클래스를 선언하고 그 클래스를 구성하는 객체에 대하여 "public" 또는 "private" 등으로 정의해준다. 이렇게 되면 "public"으로 정의된 함수 또는 데이터는 외부에서 사용할 수 있으며, "private"로 선언된 경우는 외부에서 제어할 수 없고 내부에서만 사용된다.

 1. 데이터 무결성 보장
 2. 기능의 신뢰성 향상

결과적으로 클래스의 핵심적인 데이터를 외부로부터 접근을 제한하여 데이터의 무결성을 보장해준다는 장점이 있고, 더 나아가 프로그램의 기능에 대한 신뢰성을 향상시킨다.

>*데이터 무결성(Data integrity)은 컴퓨팅 분야에서 완전한 수명 주기를 거치며 데이터의 정확성과 일관성을 유지하고 보증하는 것을 가리키며 데이터베이스나 RDBMS 시스템의 중요한 기능이다.

### Abstract(추상화) - 분리하다.

![img](/md/img/oop/abstract.png "Abstract")

추상화란 대상을 하나의 공통된 기준으로 분리한다는 개념이다.

설계적 측면에서의 추상화란 여러 모듈의 공통적인 성향을 묶고, 세부적으로 분리하여 관리를 쉽게 만들고 더 나아가 확장의 용이성을 향상한다는 방향성을 제시하고 있다.

 추상화 설계의 첫 단계는 객체들의 공통된 특성을 띤 기능을 파악하는 데 있다. 따라서 공통 기능과 비공통 기능을 식별하여 분리하고 공통 기능을 묶어 추상화 메서드로 추상화 객체에 정의한다. 이를 구현하는 실제 객체에선 추상화 메소드를 각 구현 객체에 맞게 상세히 기술하여 구현하고, 동시에 비공통 기능 또한, 각 객체의 특성에 맞게 구현한다.

 자연스레 추상화 객체와 관련된 실제 구현 객체들은 설계 구조상 묶여 있으므로 응집도가 높아지게 된다. 또한, 실제 참조하는 객체 대신 추상화 객체를 사용함으로써, 외부로부터 실제 구동되는 객체의 세부 기능은 감춰지고, 동시에 객체간 관계를 느슨하게 만들어져 결합도를 낮춰진다.

즉, 구체적인 개념보다는 추상적 개념에 의존해야 객체 간의 관계를 유연하게 만들 수 있고, 이 말인즉슨 추상적 설계를 통해, 소프트웨어의 이상적인 설계인 모듈 간의 응집도를 높이고 결합도를 낮추는 설계 방식을 구현할 수 있게 됨을 뜻한다.

이처럼 추상화를 통해 객체 간의 구조가 형성되는데, 이때 상속이라는 개념이 자연스럽게 나온다.

### Inheritance(상속성) - 관계를 맺다.

![img](/md/img/oop/inheritance.png "Inheritance")

상속이란 기존의 클래스를 전달받아서 새로운 클래스를 생성한다는 개념이다.

언어적인 측면에선 클래스의 속성과 행위를 하위 클래스에 물려주거나, 상위 클래스에서 물려받는 것을 지칭한다. 이 말인즉슨 기존의 객체와 새로운 객체 간의 관계가 형성되고, 하위 클래스는 상위 클래스가 가지고 있는 모든 데이터와 메소드를 물려받아 자유롭게 사용할 수 있고, 동시에 자신만의 데이터와 메소드를 추가로 덧붙임으로써 새로운 형태의 클래스로 발전할 수 있다.

이 때문에 비슷한 기능을 구현할 필요가 없고, 상속이라는 개념을 통해 기능을 재사용함으로써 별도의 코드를 추가할 필요가 없이 기능을 구현할 수 있다. 이는 결과적으로 중복되는 코드가 줄어들게 되고 객체를 좀 더 범용성 있게 사용할 수 있다.

예를 들어 Object로 정의한 데이터에 String, int 객체가 쓰여도 문제가 되지 않는다. 왜냐하면, String, int 객체 모두 Object 객체를 상속받은 하위 클래스이기 때문이다.  이 말인즉슨 상속 관계에 있어 하위 클래스는 상위 클래스의 기능을 포함하고 있다는 의미와 같다.

이처럼 상속이라는 메커니즘은 객체 간의 관계로부터 시작된다. 객체들의 공통점을 추출하여 상위 객체에 정의하고, 이를 전달하는 과정에서 자연스레 의존 관계가 형성하게 된다. 이처럼 기존 클래스에 하위 클래스를 추출하여 관계를 형성하는 개념과 이와 반대되는 개념이 존재하는데, 이를 소프트웨어 디자인 측면에선 특수화(상세화)와 일반화라 한다.

#### Generalization(일반화), Specialization(특수화, 상세화)

이처럼 일반화와 특수화는 설계 관점으로 클래스를 분리, 포함에 따라 정의되는 개념이다.

- Generalization
- Specialization

 일반화는 상향식(Bottom-Up)  방법으로 접근하여, 기존 클래스들의 공통점을 추출하여 상위 클래스를 만드는 것이다.

 특수화란 하향식(Top-Down)  방법으로 접근하여, 기존 클래스를 세부화하여 하위 클래스를 만드는 것이다.

 일반화는 두 개 이상의 하위 클래스에서 필수 특성 (특성, 속성 및 메서드 포함)을 추출한 다음 일반화 된 기본 클래스 (수퍼 클래스라고도 함) 내에서 결합하는 기술로 정의 할 수 있습니다. 반대로 전문화는 일반화의 반대입니다. 기존 기본 클래스에서 하위 클래스를 생성하여 "유형"관계를 나타내는 데 사용됩니다.

---

 상속은 하나 이상의 클래스 (기본 클래스라고도 함)를 확장하는 클래스의 기능으로 정의됩니다. 일반화 관계에 참여하는 클래스는 서로 밀접하게 결합되어 있기 때문에 일반화는 클래스 관계의 가장 강력한 형태입니다. 상위 클래스의 내부 복잡성 대부분이 하위 클래스에서 볼 수 있습니다.

 기본 또는 상위 클래스를 확장하는 클래스는 하위 클래스 또는 파생 클래스라고도합니다. 상속 된 클래스 또는 일반화 된 클래스는 기본 클래스 또는 상위 클래스를 상속하거나 상속합니다. 상속에서 자식 클래스는 private 클래스를 제외한 기본 클래스 또는 부모 클래스의 메서드와 특성을 상속합니다. 본질적으로 기본 클래스의 private 멤버는 자신이 속한 클래스에 "전적으로"속하기 때문에 상속되지 않습니다. 따라서 실제로는 다른 클래스의보다 특수화 된 형식 인 클래스를 나타낼 필요가있을 때만 일반화를 활용해야합니다.


 ### Polymorphism(다형성) - 다양한 형태를 제공한다.

 ![img](/md/img/oop/polymorphism.png "Polymorphism")

다형성이란 하나의 이름으로 다양한 처리 작업을 할 수 있는 개념이다.

 본래 Polymorphism의 단어는 poly(다양한) + morph(형태)의 기원으로 "다양한 형태"의 뜻을 지니고 있고, 프로그래밍에서도 이와 같은 의미로 정의한다.

 프로그래밍 측면에선 동일한 이름으로 상이한 기능을 구현하여 하나의 메시지가 객체에 따라 다르게 응답이 가능하다는 개념으로써 종류에는 오버로딩과 오버라이딩이 존재한다.

- Overloading : Same Name + Different Parameter
- Overriding : Same Name + Same Paramter

다형성의 기본적인 매커니즘은 같은 이름으로 다향한 작업을 처리한다는 기본 메커니즘을 가지고 있다. 따라서 프로그래밍에선 같은 이름, 다른 매개 변수를 정의하는 오버로딩, 같은 이름, 매개 변수를 정의하는 오버라이딩이 존재한다. 이를 소프트웨어 공학에선 오버로딩을 **수평적 다형성**으로 정의하고, 오버라이딩을 **수직적 다형성**이라 정의한다.

또한, 프로그램의 구현되는 시점에 측면에 따라 이 다형성들은 정적일 수 있고 동적일 수 있다. 오버로딩을 정적 다향성, 오버라이딩을 동적 다향성이라 부른다.

- Compile time Polymorphism : Static Polymorphism
- Runtime  Polymorphism : Dynamic Polymorphism


 간단한 단어로 오버로딩 한다는 것은 메서드를 호출하는 동안 전달 된 인수에 따라 다르게 동작하는 동일한 메서드 이름을 가진 둘 이상의 메서드를 의미합니다. 컴파일 할 때 호출 할 메소드가 결정되므로 정적이라고합니다.

 오버라이드 란 파생 클래스가 수퍼 클래스의 메서드를 구현하고 있음을 의미합니다. 재정의 된 메소드 호출은 런타임에 해석되므로 런타임 다형성 (runtime polymorphism)이라고합니다.


---


 즉, 특정 클래스의 작업에 대해 다중 구현이있는 하나의 메서드를 의미합니다. 사용되는 구현은 상황에 따라 런타임에 결정됩니다 (즉, 객체의 데이터 유형)

 이것은 특정 작업 클래스에 대한 일반적인 메서드를 제공하는 일반 인터페이스를 디자인하고 이러한 일반 메서드의 구현을 제공하는 여러 클래스가있을 수 있습니다.

 우리가 자동차의 동일한 예를 보게합니다. 자동차에는 기어 전달 시스템이 있습니다. 그것에는 4 개의 정면 장치 및 1 개의 후방 장치가있다. 엔진이 가속되면 어떤 기어가 맞 물리는 지에 따라 다른 양의 동력과 움직임이 차에 전달됩니다. 액션은 기어를 적용하는 것과 같지만 기어의 유형에 따라 동작이 다르게 동작하거나 다양한 형태를 나타낼 수 있습니다 (다형성은 여러 형태를 의미 함)

---

 다형성은 정적이고 동적 일 수 있습니다. 메소드 오버로딩 은 정적 다형성이지만 메소드 오버라이드 는 동적 다형성입니다.


  객체지향 프로그래밍은 하나의 클래스 내부에 같은 이름의 행위를 여럿 정의하거나, 상위 클래스의 오퍼레이션을 하위 클래스에서 다시 정의하여 사용할 수 있기 때문에 바로 이 다형성이라는 특징을 갖는 것이다.



### 마무리


OOP는 객체를 위주로 프로그래밍하는 컴퓨터 프로그래밍 패러다임이다. OOP에선 이 객체를 독립적인 모듈로 바라보고 있다.

독립적인 모듈이란, 다른 기능에 의존적이지 않으면서 모듈 안에 이와 관련한 요소들이 얼마나 밀집되어 있느냐에 있다. 즉, 높은 응집과 낮은 결합일수록 변화에 대처하기 쉽고, 이는 소프트웨어 공학에서 요구사항 변경에 대처하는 고전적인 설계 원리다.

이러한 이상적인 모듈화 과정에서 OOP의 다양한 특징들을 볼 수 있다.

OOP의 등장 배경을 설명하기 전에 새로운 기술이 나오는 이유에 대한 주관적인 생각을 말해보려 한다.

개발자들은 태생적으로 게으른 존재고 현재 기술이 비효율적이라고 생각이 들면 자연스레 효과적인 해결 방안을 제시하고 이를 바탕으로 새로운 기술이 나타난다. 이를 근거로 객체의 사용에 대한 물음에 대해 기존의 전통적인 소프트웨어의 개발 방식에서 답을 찾아보려 한다.

앞서 설명을 통해 OOP라는 개념을 처음 알게 되었을진 몰라도 우리는 능숙하게 OOP를 하며 개발하고 있다. 흔히 우리가 사용했던 JAVA가 바로 대표적인 객체지향 언어로 클래스, 메소드, 변수를 사용하며 개발하기 때문이다.

 이 메커니즘은 마틴 파울러가 작성한 `TellDontAsk` 글에서도 이와 관련된 개념을 찾을 수 있다.

<img src="https://martinfowler.com/bliki/images/tellDontAsk/sketch.png" height="300px">

의 기대 효과는  마틴 파울러가 작성한 `TellDontAsk`을 보면 이해하는데 도움이된다.

[정적 다형성 동적 다형성](https://wikidocs.net/495)

[difference-between-runtime-polymorphism-and-compile-time-polymorphism](https://freefeast.info/difference-between/difference-between-runtime-polymorphism-and-compile-time-polymorphism/)

[데이터 프로페셔널](http://dataprofessional.tistory.com/75)

[특징](https://gmlwjd9405.github.io/2018/07/05/oop-features.html)

[generalization-specialization-and-inheritance](https://sourcemaking.com/uml/modeling-it-systems/structural-view/generalization-specialization-and-inheritance)

[sw-design](https://awesomecodeing.blogspot.com/2013/03/inheritance-generalization-specialization-association-aggregation-composition.html)

[상속-일반화](http://burucodegallery.blogspot.com/2013/08/2-4-io-2-data-processing-steam-class.html)
