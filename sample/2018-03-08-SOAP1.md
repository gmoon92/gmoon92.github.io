---
layout: post
title: "SOAP :Simple Object Access Protocol"
tags: [SOAP]
---
SOAP(Simple Object Access Protocol)
================================
Create Date : 2018.03.23
================================
---
# 목차
## 1. SOAP란

## 2. SOAP 아키텍처

## 3. SOAP의 특징

## 4. SOAP 메시지의 구조

#### 4.1. SOAP 헤더

#### 4.2. SOAP 바디
.
## 5. SOAP의 전송방식

## 6. 그 외 Remote Call

## 7. WSDL to  Java
#### 6.1. Eclipse Web Service Client
#### 6.2. SoupUI를 이용한 WSDL Import

---

## 1. SOAP란

> **SOAP**(**S**imple **O**bject **A**ccess **P**rotocol)은</br>
일반적으로 널리 알려진 HTTP, HTTPS, SMTP 등을 통해  XML 기반의 메시지를 </br>
컴퓨터 네트워크 상에서 교환하는 <U>**프로토콜**</U>이다.</br>
</br>
SOAP는  <U>웹 서비스에서 기본적인 메시지를 전달하는 기반</U>이 된다.</br>
</br>
SOAP에는 몇가지 형태의 메시지 패턴이 있지만,</br>
보통의 경우 <U>원격 프로시져 호출(Remote Procedure Call:**RPC**) 패턴</U>으로,</br>
네트워크 노드(클라이언트)에서 다른 쪽 노드(서버)쪽으로 메시지를 요청 하고,</br>
서버는 메시지를 즉시 응답하게 된다.</br>
>
>__*RPC 패턴__
>*별도의 원격 제어를 위한 코딩 없이* </br>
>*다른 주소 공간에 있는 함수나 프로시저를 실행할 수 있게 하는 프로세스간 통신 기술.*</br>
>*즉 RPC를 이용하면 사용자는 어떤 프로그램에 대하여 그 프로그램이 로컬에 있건 원격에 있건 사용할 수 있다.*
</br>
<img  class="soap_structure_photo" width="300px" height="400px" align="left" style="margin:0 30px 30px 0;"/>
>[그림 1-1 SOAP_구조]
>SOAP는 XML-RPC와 WDDX에서 **Envelope / Header / Body**로 </br>
이루어진 구조로 되어있다.</br>
</br>
SOAP는 <U>XML을 근간</U>으로 **헤더와 바디**를 조합하는 디자인 패턴으로 설계되어 있다.</br>
</br>
**헤더**는 반복이나 보안 및 트랜잭션을 정보로 하는 메타 정보를 가지고 있다.</br>
SOAP 노드로만 처리될 애플리케이션 관련 정보를 전달하는데 사용된다.</br>
</br>
**바디**부분은 필수사항으로 주요한 정보(호출 및 응답 정보)를 가지고 있다.</br>
</br>
[참고 - 위키백과](https://ko.wikipedia.org/wiki/SOAP/) </br>
[참고 - IBM_SOAP](https://www.ibm.com/support/knowledgecenter/ko/SSMKHH_10.0.0/com.ibm.etools.mft.doc/ac55780_.htm)
></br>
></br>

<div style="clear: both; margin:30px;" />

</br>


|  |하위요소 | <center>정보 </center>|상세기술|
|:---:|:---:|:---|:---:|
|헤더|선택| 헤더정보|반복이나 보안 및 트랜잭션을 정보로 하는 메타 정보|
|바디|필수|  호출 및 응답 정보|메시지의 최종 수신인을 대상으로 하는 정보|

<pre>
            1. 정의
              -  일반적으로 널리 알려진 HTTP, HTTPS, SMTP 등을 통해
                 XML기반의 메시지를 컴퓨터 네트워크 상에서 교환하는 프로토콜

            2. 구조
              -  Envelope, Header(선택), Body(필수) 구조로 되어있다.

            3. 데이터 형태
              -  XML기반의 메시지를 활용하여 통신한다.

</pre>




<div style="clear: both; margin:30px;" />
</br>

---

## 2. SOAP 아키텍처

<img class="soap_arch_structure_photo" width="400px" height="400px"  align="left" style="margin:0 30px 30px 0"/>
[그림 2-1 SOAP_아키텍처]

#### 2.1. 설명

**UDDI 레지스트리**를 통해

**웹서비스**를

**등록(Publish)** 하고,

**탐색(Find)**  하고,

**바인딩(Bind)** 하여 사용한다. </br>

<div style="clear: both; margin:30px;" />
</br>

|  | <center>주체자 </center>| <center>상세기술 </center>|
|:---:|:---|:---|
|등록(Publish)  | Server  |  서비스 로직을 수행한 결과 데이터를 SOAP에 **인코딩**하여 **등록**  |
|탐색(find)        | Client  |   Client는 SOAP에 등록된 결과 데이터를 **탐색**|
|바인딩(Bind)  |  Client     | Client는 데이터를 SOAP로 **인코딩**하여 웹서비스 요청을 Server에게 전달|
| | Server|Server는 인코딩 된 데이터를 **디코딩**하여 해당 서비스 로직을 수행|

#### 2.2. 동작원리</br>
###### 서비스 요청자가 </br>
 SOAP로 인코딩하여 웹서비스 요청을 서비스 제공자에게 전달한다. </br>

###### 서비스 제공자는 </br>
 이를 디코딩하여 적절한 서비스 로직을 수행시켜서 결과를 얻고, </br>
그 결과를 다시 SOAP로 인코딩하여 반환한다.</br>
 [참고 - SlideShare](https://www.slideshare.net/yjaeseok/soap-rest)

 <div style="clear: both; margin:30px;" />
 </br>

 <pre>
 1. Client(서비스 요청자)는 데이터를 SOAP로 인코딩하여
 웹서비스 요청을 Server(서비스 제공자)에게 전달.

 2. Server(서비스 제공자)는 인코딩 된 데이터를 디코딩하여
 해당 서비스 로직을 수행.

 3. Server(서비스 제공자)는 결과 값을 다시 SOAP로 인코딩하여 반환.

</pre>

---

## 3. SOAP의 특징

#### 1) 장점
  *  SOAP을 사용한 HTTP는 기존 원격 기술들에 비해서 **프록시와 방화벽에 구애받지 않고 쉽게 통신 가능하다.**

  *  웹서비스를 제공하기 위한 **표준(WSDL, UDDI, WS-*)이 잘 정립되어 있다.**

  *  플랫폼, 프로그래밍 언어 **독립적이다.**

  * **확장**이 가능하다.
    1. SOAP은 융통성있게도 각각 다른 트랜스포트 프로토콜들의 사용을 허용하고 있다. </br>
  표준 스택에서는 트랜스 포트 프로토콜로 HTTP를 사용하지만, 다른 프로토콜 역시 사용 가능하다.</br>
  </br>
  * **에러처리**에 대한 내용이 기본으로 내장되어있다.

  * **분산 환경**에 적합하다.

#### 2) 단점
  * 복잡한 구조로 인한 **오버헤드**가 발생 할 수 있다.

  * 미들웨어 기술(REST와 같은)에 비해 상대적으로 **무겁고** 속도도 **느리다.**</br>
  이것은 전송할 메시지가 적을때에는 문제 되지 않을 수 있다.</br>
  </br>
  >일반적인 XML의 성능을 향상시키기 위해, </br>
  VTD-XML과 같은 emerging non-extractiv XML 처리 모델이 있다.</br>
  </br>
  바이너리 객체를 포함시킨 특별한 경우의 XML(바이너리 XML을 말하는듯)로 메시지 전송 최적화 메커니즘(Message Transmission Optimization Mechanism; MTOM)이 있다. </br>


  <div style="clear: both; margin:30px;" />
  </br>

<pre>

  1. HTTP를 통해 통신하는 프로토콜이기 때문에
    다른 RPC에 비해 Proxy와 방화벽에 제약을 받지 않고 쉽게 통신이 가능하다.

  2. 플랫폼이 독립적이며 프로그래밍 언어에 독립적이다.

  3. XML 기반으로 메시지 처리를 하는 SOAP는 메시지가 많을 수록
    미들웨어 기술에 비해 상대적으로 느리다.

</pre>

---

## 4. SOAP 메시지의 구조


>  SOAP 메시지는 선택적<'Header'> 요소와 필수 <'Body'>요소를 포함하는 <'Envelope'> 요소로 </br>
> 구성된 XML 문서로 인코딩된다.
> <'Body'>에 포함된 <'Falut'>요소는 오류보고에 사용된다.

<div style="clear: both; margin:30px;" />

 *  SOAP **엔벨로프**
   <'Envelope'>는 **모든 SOAP 메시지의 루트 요소**이며 </br>
   두 개의 하위 요소인 **선택적 <'Header'> 요소 및 필수 <'Body'> 요소를 포함**한다.

<div style="clear: both; margin:30px;" />

 * SOAP **헤더**
<'Header'>는 SOAP 엔벨로프의 **선택적 하위 요소**이며 메시지 경로를 따라</br>
**SOAP 노드로만 처리될 애플리케이션 관련 정보를 전달하는 데 사용**된다.

<div style="clear: both; margin:30px;" />

 * SOAP **본문**
<'Body'>는 SOAP 엔벨로프의 **필수 하위 요소**이며 </br>
메시지의 **최종 수신인을 대상으로 하는 정보를 포함**한다.

<div style="clear: both; margin:30px;" />

 * SOAP **결함**
 <'Fault'>는 **SOAP 본문의 하위 요소**이며 **오류 보고**에 사용된다.

---

## 4.1. SOAP 헤더

 SOAP 헤더(<헤더> 요소)는 SOAP 엔벨로프의 **선택적 하위 요소**이고</br>
메시지 플로우를 따라 **SOAP 노드로만** 처리되는 애플리케이션 **관련 정보를 전달**하는 데 사용된다.
</br>
</br>
#### 4.1.1. 헤더블록
헤더의 바로 아래 하위 요소를 헤더 블록이라 한다.</br>
헤더 블록은 애플리케이션 정의 XML 요소이고 </br>
송신자에서 최종 수신자로의 메시지 경로에서 발생할 수 있는 </br>
SOAP 노드에서 대상이 될 수 있는 데이터의 논리 그룹화를 나타낸다. </br>

**SOAP 헤더 블록**은</br>
**SOAP 중개 노드**와 **최종 SOAP 수신자 노드**로 처리할 수 있습니다. </br>
**그러나** 실제 애플리케이션에서는 <U>모든 노드가 모든 헤더 블록을 처리하는 것은 아니다. </U></br>
각 노드는 **일반적으로** 특정 헤더 블록을 처리하도록 디자인되고 각 헤더 블록은 특정 노드에 의해 처리된다.

SOAP 헤더를 사용하면 통신 당사자 간 <U>사전 합의 없이도 분산 방식으로 SOAP 메시지에 기능을 추가할 수 있다.</U> </br>
</br>

#### 4.1.2 제어정보
**SOAP** 은  </br>
기능을 처리할 수 있는 **속성**과 속성이 필수인지 또는 선택적인지 **여부**를 표시하는 데 사용할 수 있는 **일부 속성을 정의한다.**</br>
 이러한 제어 정보에는 <U>지시문 전달</U> 또는 메시지 처리에 관련된 <U>컨텍스트 정보</U> 등이 포함된다.</br>
 이 제어 정보를 통해 SOAP 메시지를 애플리케이션별 방식으로 확장할 수 있습니다.

<img  class="soap_header_structure_photo" width="800px" height="300px"/>
<div style="clear: both; margin:30px;" />
[그림 4-1 SOAP_HEADER_구조]

헤더 블록이 애플리케이션 정의되더라도</br>
헤더 블록의 SOAP 정의 속성은 헤더 블록이 SOAP 노드에 의해 처리되는 방식을 정의한다.</br>
[참고 - IBM 헤더](https://www.ibm.com/support/knowledgecenter/ko/SSMKHH_10.0.0/com.ibm.etools.mft.doc/ac55790_.htm) </br>


---
## 4.2. SOAP 바디
SOAP 바디(<바디> 요소)는 SOAP 엔벨로프의 **필수 하위 요소**이며</br>
메시지의 **최종 수신인을 대상으로 하는 정보를 포함**한다.</br>
</br>
<img class="soap_body_structure_photo" width="300px" height="300px" align="left" style="margin:0 30px 30px 0;"/>
[그림 4-2 SOAP_BODY_구조]
</br>
**바디 요소와 그에 연관된 하위 요소는 초기 SOAP 송신자와 최종 SOAP 수신자 간 정보를 교환하는 데 사용된다.**</br>
SOAP은 바디에 대해 한 개의 하위 요소인 <'Fault'> 요소를 정의하며 이 요소는 오류 보고에 사용된다.</br>
본문의 다른 요소는 해당 요소를 사용하는 웹 서비스에 의해 정의된다.</br>

[참고 - IMB 본문](https://www.ibm.com/support/knowledgecenter/ko/SSMKHH_10.0.0/com.ibm.etools.mft.doc/ac55800_.htm#ac55800_)</br>

<div style="clear: both; margin:30px;" />
</br>

#### 4.2.1 SOAP 결함(Fault)

SOAP 결함(<결함> 요소)은 SOAP 본문의 하위 요소로 오류 보고에 사용된다.

SOAP 결함 요소는 본문 항목으로 표시되어야 하고
본문 요소에 두번 이상 표시되어서는 안된다.

SOAP 결함 요소의 하위 요소는 SOAP1.1 에서와 SOAP1.2에서 다르다.

[참고 - SOAP Fault](https://www.ibm.com/support/knowledgecenter/ko/SSMKHH_10.0.0/com.ibm.etools.mft.doc/ac55810_.htm)



---

## 5. SOAP의 전송방식

 > SOAP는 인터넷 애플리케이션 계층에 있는 프로토콜을 전송계층의 프로토콜로 사용할 수 있게 만든다. </br>
 SOAP의 **반대 여론**들은 <U>프로토콜의 **의도된 목적과 역할이 맞지 않아 부정 이용이 된다고 비판**</U>하지만,</br>
  </br>
 SOAP의 **지지 여론**들은 터널링을 위한 <U>다양한 계층(level)에 쓰이고 있는 **다른 프로토콜들과 비슷**하다고 말하고 있다.</U> </br>
</br>
 **SMTP와 HTTP에서 애플리케이션 계층 프로토콜로 트랜스포트 계층의 역할을 대신하는 것이 SOAP의 올바른 이용**이라 할 수 있으나, </br>
 HTTP는 오늘날 인터넷 인프라와 매우 잘 동작하여 더욱 폭넓은 지원을 가능하게 한다. </br>
 </br>
 특히나, HTTP는 방화벽이 작동하는 네트워크 안에서도 문제 없이 작동한다. </br>
 SOAP는 HTTPS(애플리케이션 계층에서는 HTTP와 동일하나 트랜스포트 계층 아래에서는 암호화됨)에서도 간략하게 또는 상호적으로 사용된다.
 </br>
 [참고 - 위키백과 전송방식](https://ko.wikipedia.org/wiki/SOAP)

---


## 6. 그 외 Remote Call

#### 6.1. Client-Server Model
Client-Server 모델은 P2P모델(분산 된 네트워킹)과 달리 **중앙 집중식 네트워킹이다.**

<img  class="client_server_photo1" width="300px" height="350px"  align="left" style="margin:0 30px 30px 0;"/>

Client와 Server가 서비스를 요청 또는 응답할때 </br>
주로 Socket 프로그래밍을 활용했다.</br>
</br>
Socket 프로그래밍은</br>
대부분의 프로그래밍 언어에서 API 형태로 제공한다.</br>
</br>

Client-Server모델을 사용하여 통신하기 위해선 몇 가지 제약이 있다.

  * 서버는 클라이언트가 요청 시 언제든 즉시 응답하여야 한다.
  * 클라이언트는 언제든 서버에게 요청할 수 있어야 한다.

그러나 현실은 언제나 네트워크, 서버, 클라이언트 모두 느려지고</br>
각종 문제를 발생 할 수 있다.
</br>
개발자는 통신할때 예외 상황들을 고려하여 개발하여야 한다.
이를 대체하고자 RPC 모델이 등장한다.


<div style="clear: both; margin:30px;" />
</br>

---

#### 6.2. RPC (Remote Procedure Call)

<img  class="rpc_photo1" width="400px" height="350px"  align="left" style="margin:0 30px 30px 0;"/>

RPC는 별도의 원격 제어를 위한 코딩 없이 </br>
다른 주소 공간에서 함수나 프로시저를 실행할 수 있게하는  </br>
프로세스 간 통신 기술이다. </br>
</br>
RPC 통신 기술을 사용하면</br>
개발자는 ***IDL** 을 활용하여 network 통신과 관련된 작업을 신경쓰지 않아도 된다.</br>
</br>
원격지에 위치한 프로그램을 로컬에 있는 프로그램처럼 사용 할 수 있다.</br>

__**IDL : Interface Definition Language*__
[참고 - Introduction to Remote Procedure Call (RPC)](https://www.slideshare.net/ZiKaS/introduction-to-remote-procedure-call)
[참고 - Remote Procedure Call](https://middlewares.wordpress.com/2008/02/01/remote-procedure-call/)


<div style="clear: both; margin:30px;" />
</br>

---

#### 6.3 CORBA , RMI

 **CORBA(Common Object Request Broker Architecture)** 는 </br>
 다른 OS, 프로그램언어로 작성되고 분산된 환경에서 소프트웨어 간의 통신을 가능하게한다.</br>
로컬/원격을 포괄한 프로그램으로 객체 간의 메소드 호출 의미를 표준화한다는 목적으로 OMG에서 정의한 규격이다.

**RMI(Remote Method Invocation)** 는 </br>
 JAVA환경에서 하나의 JVM에서 다른 JVM으로 메소드 호출을 지원한다.

[참고 - RMI, CORBA and NetBeans - Sing Li](http://www.developerfusion.com/article/84316/rmi-corba-and-netbeans)

[참고 - Java RMI & CORBA. A comparison of two competing technologies](http://www.javacoffeebreak.com/articles/rmi_corba/)

[참고 - 원격 객체 통신(RMI와 CORBA) - 윤경구](http://javadom.com/tutorial/rmi-idl/)

[참고 - RPC, RMI, CORBA의 복잡성, 개발의 어려움, 보안 문제](https://stackoverflow.com/questions/3835785/why-has-corba-lost-popularity)

[참고 - RPC에서 REST까지 간단한 개념소개](https://www.slideshare.net/WonchangSong1/rpc-restsimpleintro)
</br>

