---
layout: post
title: "OOP의 특징"
tags: [OO, OOP-features, OOP-Principles]
categories: [OO]
subtitle: "OOP를 하면서, 무심코 지나쳤던 OOP의 특징들"
feature-img: "md/img/thumbnail/oop.png"
thumbnail: "md/img/thumbnail/oop.png"
excerpt_separator: <!--more-->
sitemap:
display: "false"
changefreq: daily
priority: 1.0
---

<!--more-->

# OOP를 하면서, 무심코 지나쳤던 OOP의 특징들

---

### 들어가기전

본 포스팅은 OOP를 하면서 무심코 지나쳤던 OOP의 특징에 대해 알아보려 한다. 흔히 "캡추다산정"이라 불리는 캡슐화, 추상화, 다형성, 상속성, 정보 은닉의 개념과 실제 어디서 활용했었는지에 대해 작성할 예정이다. 객체지향, OOP의 개념적인 부분은 아래 링크를 참고하기 바란다.

>[1. 객체지향에 대해](https://gmun.github.io/oo/2018/11/12/oo.html) <br/>
>[2. OOP에 대한 고찰](https://gmun.github.io/oo/2018/11/20/oop.html) <br/>

### 학습 목표

1. 캡슐화에 대한 이해
2. 추상화에 대한 이해
3. 다형성에 대한 이해
4. 상속성에 대한 이해
5. 정보 은닉에 대한 이해

---

### Encapsulation(캡슐화) - 묶고, 숨기다.

![img](/md/img/oop/encapsulation.png "Information hiding")

캡슐화의 정의는 언어 측면과 기술 측면으로 정의할 수 있다.

- 언어 측면 : 객체의 속성(data fields)과 행위(methods)를 하나로 묶어져 있는 언어적 구조
- 기술 측면 : 일부 구현 내용을 외부에 감추어 은닉

이처럼 두 가지 측면은 다른 의미를 다루고 있지만, **모듈의 재사용성 향상**이라는 하나의 방향성을 띄고 있다.

<img src="/md/img/oop/encapsulation1.png" style="max-height:none">

먼저 언어적 측면으로는 흔히 클래스를 정의하고 내부에 데이터와 메소드를 정의하고, 정의된 클래스를 프로그램의 독립적인 단일 단위로 바라본다는 개념이다. 이는 클래스 기반 언어의 언어 구조 특징으로, 이를 캡슐화라 정의한다.

 하지만 단순히 클래스 기반 언어의 구조 특징을 캡슐화라 정의할 수 없다. 캡슐화란 클래스 기반 언어의 구조적인 개념에 국한되어있지 않고, 다른 언어에서도 캡슐화란 개념이 나오기 때문이다. 이러한 이유는 캡슐화란 일부 구현 기능의 은닉 정도를 제어한다는 측면으로 바라보는 개념이 있기 때문이다.

이 개념을 정보 은닉(Data hiding)이라 하는데, 캡슐화에선 이 개념을 통해 기능의 단순화라는 방향성에 초점을 두고 있다. 언어적 측면에서는 접근 제한자를 통해 이 메커니즘을 구현할 수 있다.

<img src="/md/img/oop/encapsulation2.png" style="max-height:none">

 다음 그림을 보면 `Alam` 클래스 내부에 일부 데이터들을 접근 제한자를 지정하여 외부로부터 직접적인 데이터 접근을 제한하고 있다. 이처럼 클래스 내부에서 실제적으로 데이터를 조작하는 메소드 또는 핵심 데이터를 은닉하고, 직접 호출하지 않는 대신, 필요에 따라 사용할 수 있는 기능을 외부에 공개한다.

<img src="/md/img/oop/encapsulation3.png" style="max-height:none">

 결과적으로 개발자는 필요한 메소드만 호출하여 데이터를 얻을 수 있고, 동시에 다른 기능, 데이터에 영향을 미치지 않고 변경될 수 있다. 무엇보다 데이터를 조작하기 위한 세부적인 구현 기능을 외부의 접근으로부터 제한하고 클래스 내부 안에서 동작하기 때문에, 객체라는 단위를 보다 하나의 독립적인 단위로 바라보고 결과적으로 객체의 기능을 재사용성이 향상된다.

 정리하자면 캡슐화 개념은 독립적인 모듈화를 기본 메커니즘을 따르고, 동시에 객체의 기능을 적용하는 과정에 더 쉽게 접근하기 위해 일부 데이터 접근을 제한하는 데이터 은닉이라는 개념을 사용한다.

가끔, 캡슐화와 정보 은닉(Information Hiding)에 대해서 혼란을 겪을 수 있는데, 캡슐화는 모듈화(modularity)의 중점으로 둔 개념이고, 정보 은닉은 직접적인 데이터 접근에 대한 개념을 중점으로 두고 있다. 따라서 잘 된 캡슐화는 정보 은닉의 내용을 포함하고 있다.

### Information hiding(정보 은닉) - 보호하다.

![img](/md/img/oop/information-hiding.png "Information hiding")

 정보 은닉은 외부에서 데이터 접근을 제한한다는 개념이다.

 언어적 측면에서 정보 은닉은 접근 제한자를 통해 은닉의 정도를 구현할 수 있다. 따라서 클래스의 데이터 또는 메소드에 접근 제한자를 기술하여 외부에서 데이터 접근을 제한할 수 있다.

<img src="/md/img/oop/access-limiter.png" style="max-height:none">

- private : 자기 클래스 내부의 메서드에서만 접근 허용
- default : 같은 패키지에 있는 객체만 접근 허용
- protected : 같은 패키지에 있는 객체 또는 상속받은 자식 클래스에서 접근 허용
- public : 모든 접근을 허용

프로그래밍에 있어 이러한 접근 제한자들은 클래스 외부로부터 제한된 접근 권한을 제공하며 원하지 않는 외부의 접근에 대해 내부를 보호하는 작용을 한다. 이렇게 함으로써 이들 부분이 프로그램의 다른 부분들에 영향을 미치지 않고 변경될 수 있다.

 예를 들면, 클래스를 선언하고 그 클래스를 구성하는 객체에 대하여 "public" 또는 "private" 등으로 정의해준다. 이렇게 되면 "public"으로 정의된 함수 또는 데이터는 외부에서 사용할 수 있으며, "private"로 선언된 경우는 외부에서 제어할 수 없고 내부에서만 사용된다.

결과적으로 클래스의 핵심적인 데이터를 외부로부터 접근을 제한하여 데이터의 무결성을 보장해준다는 장점이 있고, 더 나아가 프로그램의 기능에 대한 신뢰성을 향상시킨다.

1. 데이터 무결성 보장
2. 기능의 신뢰성 향상

>*데이터 무결성(Data integrity)은 컴퓨팅 분야에서 완전한 수명 주기를 거치며 데이터의 정확성과 일관성을 유지하고 보증하는 것을 가리키며 데이터베이스나 RDBMS 시스템의 중요한 기능이다.

### Abstract(추상화) - 분리하다.

![img](/md/img/oop/abstract.png "Abstract")

추상화란 대상을 하나의 공통된 기준으로 분리한다는 개념이다.

따라서 OOP에선 여러 공통적인 성향을 띈 객체들을 세부적으로 분리하여 관리를 쉽게 만들고 더 나아가 확장의 용이성을 향상한다는 방향성을 제시하고 있다.

추상화에선 먼저 객체들의 공통된 데이터를 파악한다. 여기서 데이터란 기능 또는 이와 관련된 데이터를 뜻한다. 본론으로 돌아와서 정의된 기능들을 추상화 객체로 정의하고 이를 구현하는 객체에서 추상 기능을 세부적으로 구현하게 된다.

따라서 정의된 추상화 객체는 이를 구현하는 객체들과 관계를 맺기 때문에 자연스레 응집도가 높아지고, 동시에 실제 참조하는 객체 대신 추상화 객체를 사용함으로써 실제 구현되는 객체의 세부 기능은 감춰지게 됨으로써 관계를 느슨하게 만들어진다. 즉 객체 구조 간의 결합도를 낮춰진다.

 정리하자면 추상화란 설계의 개념으로써 구체적인 개념보다는 추상적 개념에 의존해야 객체 간의 관계를 유연하게 만들 수 있다. 결과적으로 추상적 설계를 통해, 소프트웨어의 이상적인 설계인 모듈 간의 응집도를 높이고 결합도를 낮추는 설계 방식을 구현할 수 있게 된다.

이처럼 추상화를 통해 객체 간의 구조가 형성되는데, 이때 상속이라는 개념이 자연스럽게 나온다.

### Inheritance(상속성) - 관계를 맺다.

![img](/md/img/oop/inheritance.png "Inheritance")

상속이란 기존의 클래스를 전달 받아서 새로운 클래스를 생성한다는 개념이다.

언어적인 측면에선 클래스의 속성과 행위를 하위 클래스에 물려주거나, 상위 클래스에서 물려받는 것을 지칭한다. 이 말인즉슨 기존의 객체와 새로운 객체 간의 관계가 형성되고, 하위 클래스는 상위 클래스가 가지고 있는 모든 데이터와 메소드를 물려받아 자유롭게 사용할 수 있고, 동시에 자신만의 데이터와 메소드를 추가로 덧붙임으로써 새로운 형태의 클래스로 발전할 수 있다.

이 때문에 비슷한 기능을 구현할 필요가 없고, 상속이라는 개념을 통해 기능을 재사용함으로써 별도의 코드를 추가할 필요가 없이 기능을 구현할 수 있다. 이는 결과적으로 중복되는 코드가 줄어들게 되고 객체를 좀 더 범용성 있게 사용할 수 있다.

예를 들어 Object로 정의한 데이터에 String, int 객체가 쓰여도 문제되지 않는다. 왜냐하면 String, int 객체 모두 Object 객체를 상속받은 하위 클래스이기 때문이다.

- Generalization(일반화)
- Specialization(특수화)

 ### Polymorphism(다형성) - 다양한 형태를 제공한다.

 ![img](/md/img/oop/polymorphism.png "Polymorphism")

 셋째, 다형성이 있습니다. 다형성이란 하나의 이름(방법)으로 많은 상황에 대처하는 기법입니다. 개념적으로 동일한 작업을 하는 함수들에 똑같은 이름을 부여할 수 있으므로 코드가 더 간단해지는 효과가 있습니다.


  다형성은 객체지향의 개념에서 가장 중요한 특징이라고 말할 수 있다. 다형성이란 사전적 의미로 '다양한 형태로 나타날 수 있는 능력'을 뜻한다.



  객체지향 프로그래밍은 하나의 클래스 내부에 같은 이름의 행위를 여럿 정의하거나, 상위 클래스의 오퍼레이션을 하위 클래스에서 다시 정의하여 사용할 수 있기 때문에 바로 이 다형성이라는 특징을 갖는 것이다.

 ---

 이 게시물은 다형성에 대한 이론적 인 설명과 실제 사례를 제공합니다. Java 프로그램에서이 주제에 대한 자세한 설명 은 java 및 런타임의 다형성 및 컴파일 시간 다형성을 참조하십시오 .

 다형성이란 데이터 유형에 따라 객체를 다르게 처리하는 것을 의미합니다.
 즉, 특정 클래스의 작업에 대해 다중 구현이있는 하나의 메서드를 의미합니다. 사용되는 구현은 상황에 따라 런타임에 결정됩니다 (즉, 객체의 데이터 유형)
 이것은 특정 작업 클래스에 대한 일반적인 메서드를 제공하는 일반 인터페이스를 디자인하고 이러한 일반 메서드의 구현을 제공하는 여러 클래스가있을 수 있습니다.
 우리가 자동차의 동일한 예를 보게합니다. 자동차에는 기어 전달 시스템이 있습니다. 그것에는 4 개의 정면 장치 및 1 개의 후방 장치가있다. 엔진이 가속되면 어떤 기어가 맞 물리는 지에 따라 다른 양의 동력과 움직임이 차에 전달됩니다. 액션은 기어를 적용하는 것과 같지만 기어의 유형에 따라 동작이 다르게 동작하거나 다양한 형태를 나타낼 수 있습니다 (다형성은 여러 형태를 의미 함)

 다형성은 정적이고 동적 일 수 있습니다. 메소드 오버로딩 은 정적 다형성이지만 메소드 오버라이드 는 동적 다형성입니다.

 간단한 단어로 오버로딩 한다는 것은 메서드를 호출하는 동안 전달 된 인수에 따라 다르게 동작하는 동일한 메서드 이름을 가진 둘 이상의 메서드를 의미합니다. 컴파일 할 때 호출 할 메소드가 결정되므로 정적이라고합니다.
 오버라이드 란 파생 클래스가 수퍼 클래스의 메서드를 구현하고 있음을 의미합니다. 재정의 된 메소드 호출은 런타임에 해석되므로 런타임 다형성 (runtime polymorphism)이라고합니다.


### 마무리


OOP는 객체를 위주로 프로그래밍하는 컴퓨터 프로그래밍 패러다임이다. OOP에선 이 객체를 독립적인 모듈로 바라보고 있다.

독립적인 모듈이란, 다른 기능에 의존적이지 않으면서 모듈 안에 이와 관련한 요소들이 얼마나 밀집되어 있느냐에 있다. 즉, 높은 응집과 낮은 결합일수록 변화에 대처하기 쉽고, 이는 소프트웨어 공학에서 요구사항 변경에 대처하는 고전적인 설계 원리다.

이러한 이상적인 모듈화 과정에서 OOP의 다양한 특징들을 볼 수 있다.

OOP의 등장 배경을 설명하기 전에 새로운 기술이 나오는 이유에 대한 주관적인 생각을 말해보려 한다.

개발자들은 태생적으로 게으른 존재고 현재 기술이 비효율적이라고 생각이 들면 자연스레 효과적인 해결 방안을 제시하고 이를 바탕으로 새로운 기술이 나타난다. 이를 근거로 객체의 사용에 대한 물음에 대해 기존의 전통적인 소프트웨어의 개발 방식에서 답을 찾아보려 한다.

앞서 설명을 통해 OOP라는 개념을 처음 알게 되었을진 몰라도 우리는 능숙하게 OOP를 하며 개발하고 있다. 흔히 우리가 사용했던 JAVA가 바로 대표적인 객체지향 언어로 클래스, 메소드, 변수를 사용하며 개발하기 때문이다.



 이 메커니즘은 마틴 파울러가 작성한 `TellDontAsk` 글에서도 이와 관련된 개념을 찾을 수 있다.

<img src="https://martinfowler.com/bliki/images/tellDontAsk/sketch.png" height="300px">

의 기대 효과는  마틴 파울러가 작성한 `TellDontAsk`을 보면 이해하는데 도움이된다.


---

[데이터 프로페셔널](http://dataprofessional.tistory.com/75)

[특징](https://gmlwjd9405.github.io/2018/07/05/oop-features.html)

[관계](https://sourcemaking.com/uml/modeling-it-systems/structural-view/generalization-specialization-and-inheritance)


[일반화- 특수화](https://books.google.co.kr/books?id=x--MCwAAQBAJ&pg=PT200&lpg=PT200&dq=%EC%9D%BC%EB%B0%98%ED%99%94+%ED%8A%B9%EC%88%98%ED%99%94&source=bl&ots=jQhWkT1Tar&sig=sqh4wIWHsrAguS7caRCfjaHsNdI&hl=ko&sa=X&ved=2ahUKEwjF8P_50ZTfAhUKerwKHcTdD6UQ6AEwDHoECAIQAQ#v=onepage&q=%EC%9D%BC%EB%B0%98%ED%99%94%20%ED%8A%B9%EC%88%98%ED%99%94&f=false)
