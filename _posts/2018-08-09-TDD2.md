---
layout: post
title: "TDD : JUnit 사용법"
tags: [TDD]
subtitle: "Chapter2 JUnit을 통한 TDD"
display: "false"
excerpt_separator: <!--more-->
sitemap:
changefreq: daily
priority: 1.0
---

<!--more-->

# Chapter2. JUnit을 통한 TDD

---

### JUnit?

`JUnit`은 `xUnit`의 `Library` 중에서 `Java`의 단위 테스트를 지원하는 `Library`이다.<br/>

`TDD` 개발론에 있어 테스트 후 개발은 가장 중요한 원칙이다. 즉 `TDD`는 테스트 코드를 작성하는 것으로 부터 시작이다.<br/>
이에 `JUnit`은 테스트 코드를 작성할 수 있도록 다양한 어노테이션과 메소드를 지원한다.<br/>
`JUnit`은 GUI기반으로 테스트 결과에 대해 직관적으로 볼 수 있고 .jar 파일로 설정이 간단한 편이다. 무엇보다 자바 개발자들이 테스트 도구로 애용하고 있고, 꾸준한 버전업이 이루워지고 있다.

>단위 테스트 프레임워크는 켄트 벡(Kent Beck)이 고안한 것으로, `SUnit`이라는 이름으로 `Smalltalk`에 처음 적용됐다. 이후 에릭 감마(Erich Gamma)와 켄트 벡(Kent Beck)이 `Java`에 포스팅하여 `JUnit`이 탄생했다. <br/>[Wikipedia JUnit](https://en.wikipedia.org/wiki/JUnit)

---

### 값을 검증하기 위한 단정문 (Assert)

`JUnit`에서 `Assert`는 두개의 값이 같다고 가정하여 테스트의 통과여부를 진행한다. <br/>
 대부분 `Assert` 메소드들은 `assert...(에러메시지(선택), 기대 값, 비교 값)`이라는 간단한 규칙을 따르고 있다.<br/>
첫번째 매게변수에 에러 메시지를 포함할 수 있고 가정문이 기대하는 값과 다를 경우에 에러 메시지를 반환한다.

|  단정문  | 상세 설명 |
|:---------------|:-----|
|assertEquals(a,  b) | 2개의 **객체**가 동일하다고 가정한다.|
|assertArrayEquals(Object[] a, Object[] b) |2개의 **배열**이 동일하다고 가정한다. |
|assertThat(T actual, Matcher<T> matcher)|  기대 값과 비교로직이 담긴 Matcher를 동일하다고 가정한다.|
|fail()| 강제로 테스트를 실패한다. |
|assertSame(a,b)<br/>assertNotSame(a, b) | 두 객체가 **동일한 객체**를 참조하는지 가정한다. <br/> 두 객체가 **동일하지 않는 객체**를 참조하는지 가정한다.|
|assertTrue(a)<br/>assertFalse(a) | **조건이 true**인지 가정한다. <br/> **조건이 false**인지 가정한다.|
|assertNull(a) <br/> assertNotNull(a) | 객체가 null임을 가정한다. <br/> 객체가 null이 아님을 가정한다. |


#### 객체를 검증하는 assertEquals(기대 값, 비교 값)

assertEquals(기대 값, 비교 값)을 규칙으로 값을 검증한다.<br/>
숫자 자료형 검증은 assertEquals(기대 값, 비교값, 오차범위)을 규칙으로한다.
 
```java
@Test
public void assertEqualsTest(){
  Object a = "value";
  String b = "value";

  int   c = 1;
  float d = 1;

  // Success
  assertEquals("다형성" , a, b);
  assertEquals("실수 정수 값 비교" , c, d, 0); // 숫자 자료형 단정문  assertEquals(기대 값, 비교 값, 오차범위);

  // faile
  assertEquals("실수 정수 값 비교" , 2, c, 0); // java.lang.AssertionError: 실수 정수 값 비교 expected:<2.0> but was:<1.0>
}
```

#### 배열을 검증하는 assertArrayEquals(기대 값, 비교 값)

```java
@Test
public void assertArrayEqualsTest(){
  Object[] arrayA = new Object[4];

  Object[] arrayB = new String[4];
  Object[] arrayC = new String[4];
  Object[] arrayC1 = new String[]{"a","a","a","a"};

  Object[] arrayD = new String[3];

  // Success
  assertArrayEquals("다형성 ", arrayA, arrayB);
  assertArrayEquals("같은 자료형 배열", arrayB, arrayC);

  // faile
  assertArrayEquals("크기가 다른 배열", arrayB, arrayD); 	// 크기가 다른 배열: array lengths differed, expected.length=4 actual.length=3
  assertArrayEquals("다른 값 배열", arrayC, arrayC1);   	// 다른 값 배열: arrays first differed at element [0]; expected:<null> but was:<a>
}
```

#### 그 이외의 단정문들

강제 에러 발생을 처리가 가능한 `faile` 메소드는 코드베이스에서 조건문을 통해 테스트를 실패시킬 수도 있다.<br/> 
`assertThat`은 기존의 값과 값을 검증하는것이 아닌 비교로직이 담긴 Matcher 통해 기대 값을 유연성 있게 검증할 수 있다. <br/>
예를 들어 "ABCD"라는 문자열에 "A"가 포함되어 있는지, 내부에 선언된 모든 매처가 정상일 경우 테스트가 통과 된다라던지 이처럼 유연성 있게 값을 검증할 수 있다. <br/>

> Matcher는 assertThat는 org.hamcrest.CoreMatchers 클래스에 선언된 메서드를 통해 사용할 수 있다. <br/>
> [참고 JUnit DOC(org.hamcrest.core)](https://junit.org/junit4/javadoc/latest/index.html)

```java
@Test
public void test(){
  Object obj = null;

  boolean a = true;
  boolean b = false;

  boolean[] arrayA = new boolean[4];

  // Success
  assertSame("동일한 객체 테스트", true, a);
  assertNull("객체 null 테스트", obj);
  assertTrue("조건 테스트", a);
  assertFalse("조건 테스트", b);
  assertThat("that 테스트", a, is(true));

  // faile
  assertSame("동일한 객체 테스트", a, arrayA);
  assertNull("객체 null 테스트", a);
  assertNotNull("객체 not null 테스트", obj);

  if(a){
    fail("강제 에러");
  }
}

```

---

### JUnit4의 어노테이션

`JUnit`은 어노테이션을 통해 메소드 또는 클래스에 대해 기능을 정의한다.
[JUnit doc](https://junit.org/junit4/javadoc/latest/index.html)를 참고했다.

|  어노테이션 | 정의 |
|:---------------|:-----|
||**메소드에 사용되는 어노테이션**|
|1)@Test <br/> 2)@Test(timeout=long) <br/> 3)@Test(expected=Class<? extends Throwable>) |1) 메소드를 테스트 메소드로 지정한다.<br/> <br/> 2) while 같은 무한 루프를 포착하고 종료하는 데 유용하다. <br/>테스트 메소드가 지정한 ms(milliseconds *1000ms = 1초)보다 오래 걸리면 실패한다. <br/>  예) `@Test(timeout=100)`<br/> <br/>  3) 예외 검증해야되는 경우 사용가능하다.<br/>테스트 메소드가 정의된 해당 예외를 throw하지 않거나 선언 된 예외와 다른 예외를 throw하는 경우 실패한다. <br/>예)` @Test(expected=IndexOutOfBoundsException.class)` <br/> |
|@BeforeClass| 클래스가 포함한 테스트를 실행하기 전, 맨 처음에 단 한 번만 실행된다.<br/> 예)  환경 셋팅(DB 연결)을 할때 쓰인다. 반드시 static 메소드로 정의한다.|
|@AfterClass| 클래스가 포함한 테스트를 모두 실행한 뒤 단 한 번만 실행된다. <br/> 예) 환경 셋팅을 정리(DB 연결을 끊을때)할때 쓰인다. static 메소드로 정의한다.|
|@Before| 각각의 테스트 메소드가 실행하기 전에 실행된다. <br/> 예) 테스트 환경을 준비하는데 사용된다.(초깃값 입력, 클래스 초기화)|
|@After|각각의 테스트 메소드가 실행을 한 후에 실행된다. <br/> 예) 테스트 환경을 정리하는데 사용된다.(임시 데이터 삭제, 기본값 복원)|
|@Rule| TestRule을 구현한 클래스에 따라 `@Before`와 `@After` 실행 전 후에 실행된다. 반드시 public이여야 된다. 필드 또는 메소드에 TestRule을 구현한 클래스여야된다. <br/><br/>예) 공통적은 setUp() 또는 tearDown() 같은 메소드 작업을 사용할 경우에 `@Before`와 `@After`보다는 `@Rule`을 쓰는것이 바람직하다.|
|@RuleClass| TestRule을 구현한 클래스에 따라 `@BeforeClass`와 `@AfterClass` 실행 전 후에 실행된다. 반드시 static이여야 된다.|
| |**클래스 또는 메소드에 사용되는 어노테이션**|
|@Ignore, <br/>@Ignore(왜 비활성화 시켰는지?)|테스트 메소드, 클래스를 비활성화 시킨다. <br/> 예) 1) 테스트 케이스가 아직 적용이 되지 않은 경우 <br/>  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2) 테스트의 실행 시간이 너무 길어서 포함될 수 없는 경우|
| |**클래스에 사용되는 어노테이션**|
|@RunWith|  `@RunWith`에 명시된 클래스를 확장할 수 있다.<br/> JUnit은 각각의 테스트가 서로 영향을 주지 않고 독립적으로 실행한다. 때문에 각각의 `@Test`마다 오브젝트를 생성한다. 이와 같은 JUnit의 특성으로 인하여 ApplicationContext도 매번 느려지는 단점이 있다.<br/>그러나 `@RunWith`은 각각의 테스트별로 오브젝트가 생성이 되더라도 싱글톤의 ApplicationContext를 보장하는 역할을 한다.<br/> 예) `@RunWith(SpringJUnit4ClassRunner.class)`|
|@FixMethodOrder (MethodSorters.Enum)| 클래스가 포함한 메소드의 실행 순서를 지정한다. <br/>이 어노테이션은 JUnit 4.11 버전 이후  부터 지원한다. <br/><br/> 예) 1) `@FixMethodOrder (MethodSorters.DEFAULT)` <br/> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; `DEFAULT` : HashCode를 기반으로 순서가 결정되어 실행한다.  <br/> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2) `@FixMethodOrder (MethodSorters.JVM)` <br/> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; `JVM` : JVM에서 반환 한 순서대로 실행한다.<br/>  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3) `@FixMethodOrder (MethodSorters.NAME_ASCENDING `<br/> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; `NAME_ASCENDING` : 메소드 명을 오름차순으로 정렬한 순서로 실행한다. <br/> |

### JUnit 생명주기

아래의 코드는 `JUnit`의 어노테이션의 생명주기를 살펴보기 위해 작성했다.

```java
package com.test.jUnitPratice.tddJunit;

import org.junit.*;	// JUnit 사용하기 위한 import문
import org.junit.runners.MethodSorters; // @FixMethodOrder Option을 사용하기 위한 import문

import com.test.jUnitPratice.tddJunit.util.CustomClassRule; // 직접 Rl


@FixMethodOrder(MethodSorters.JVM) // JVM이 반환한 순서대로 실행
public class JunitTest {

	@ClassRule
	public static CustomClassRule classRule = new CustomClassRule();

	@Rule
	public CustomRule rule = new CustomRule();

	@BeforeClass
	public static void beforeClass(){ // 반드시 static method
		System.out.println("*******************");      // @BeforeClass
		System.out.println("@BeforeClass");             // 단 한번만 실행된다. 보통 DB연결을 할때 쓰인다.
	}

	@AfterClass
	public static void afterClass(){ // 반드시 static method
		System.out.println("@AfterClass");             // @AfterClass
		System.out.println("*******************");     // 단 한번만 실행된다. 정리 작업을 수행하는 데 사용된다.(보통 DB 연결을 끊을때 쓰인다.)
	}

	@Before // 각 Test 메소드가 실행 전에 실행
	public void before(){
		System.out.println();                          // @Before
		System.out.println("@Before");                 // 테스트 환경 구성 (입력 데이터 초깃값, 클래스 초기화를 사용하는데 사용된다.)
	}

	@After // 각 Test 메소드가 실행 후에 실행
	public void after(){
		System.out.println("@After");                  // @After
		System.out.println();                          // 테스트 환경 정리(임시 데이터 삭제, 기본값 복원, 비싼 메모리 구조를 정리하여 메모리 절약 등)
	}

	/**
	 * @Test
	 * Test 정의
	 * */

	@Test // 해당 메소드를 Test 메소드로 인식
	public void test1(){ System.out.println("@Test test1"); }

	@Test // 해당 메소드를 Test 메소드로 인식
	public void test2(){ System.out.println("@Test test2"); }

	/**
	 * @Ignore, @Ignore("ignore Test")
	 * Test 제외
	 * */
	@Test
	@Ignore("ignore Test") // 제외 시킨 이유를 정의 할 수 있다.
	public void ignoreTest(){ System.out.println("@Ignore"); }
}

```

#### 커스텀 @RuleClass 구현 CustomClassRule.java

`JUnit`은 `DisableOnDebug`, `ErrorCollector`, `ExpectedException`, `TemporaryFolder` 등  `Rules` 기본적으로 제공하고 있다.<br/>
`JUnit`의 생명주기를 테스트하기 위해 기존에 제공하는 `Rules`가 아닌 TestRule를 상속하여 CustomClassRule를 만들었다.

> [참고 JUnit DOC(org.junit.rules)](https://junit.org/junit4/javadoc/latest/index.html)

```java
package com.test.jUnitPratice.tddJunit.util;

import org.junit.rules.TestRule;
import org.junit.runner.Description;
import org.junit.runners.model.Statement;

public class CustomClassRule implements TestRule {

	@Override
	public Statement apply(final Statement base, Description description) {
		return new Statement() {

			@Override
			public void evaluate() throws Throwable {
				//code here executes before test runs
				startClassRule();
				base.evaluate(); // test가 실행되는 지점 (@Test)
				endClassRule();
				//code here executes after test is finished
			}
		};
	}

	private void startClassRule(){
		System.out.println("@start ClassRule" );
	}

	private void endClassRule(){
		System.out.println("@end ClassRule" );
	}

}
```

<img src="/md/img/TDD/JUnit/2.png" height="500px">
<em>JUnit 생명주기 테스트 결과</em>

테스트의 결과를 보면 다음과 같다.<br/>

1) `@ClassRule`, `@BeforeClass`가 실행된다. <br/>
2) `@Test` 메소드가 실행 될때마다 `@Rule`, `@Before`, `@After` 인스턴스가 생성된다. <br/>
3) `@AfterClass`, `@ClassRule`이 실행된다. <br/>
4) 녹색!! 테스트가 성공적으로 진행됐음을 알 수 있다. <br/>
5) 테스트가 진행된 `@Test` 메소드 목록이다. <br/>

#### 메소드 단위생명주기

<img src="/md/img/TDD/JUnit/1.png" height="400px">
<em>JUnit 메소드 단위생명주기</em>

위 그림은 테스트의 결과에 따른 생명주기를 그림으로 표현했다.<br/>
그림을 보면 각각의 `@Test` 메소드가 실행되는 과정에서 `@Before`, `@After` 매번 인스턴스를 생성한다.<br/>
매번 인스턴스를 생성함으로 `@Test` 메소드 사이의 상호관계에서 발생하는 부작용을 방지하고 `@Test` 메소드가 독립성을 보장받게 된다. 
각각의 `@Test` 메소드가 실행되기 전에 새로운 인스턴스를 생성하기 때문에 각각의 `@Test` 메소드는 독립적인 객체환경에서 동작할 수 있다. 이를 메소드 단위생명주기라한다.

---

### TDD 연습하기

TDD를 개발 연습할 때는 유틸성 기능 또는 알고리즘 문제를 통해 연습하면 좋다.<br/>
유틸성 문제 중 가장 기초적인 문자열 계산기를 만들어보자.<br/>

> 문제 1) 더하기, 빼기, 나누기, 곱셈할 수 있는 계산기 만들기

#### 먼저 TestCase를 작성하자

`TDD`는 테스트 코드를 작성하기 이전에 테스트 케이스를 추출하는 것부터 시작한다.<br/>
개발자는 테스트 케이스를 통해 개발의 진척도를 직관적으로 알 수 있다.
또한, 목록을 하나씩 지울 때마다 소소한 성취감을 느낄 수 있고 무엇보다 해야 할 일들이 눈에 보이기 때문에 앞만 보고 개발을 진행할 수 있다.

##### 목표 세우기

"테스트 케이스를 어떻게 작성하면 좋을까?"라는 의문이 생긴다. 이러한 문제는 목표설정에 있어 `SMART` 기법을 활용하여 편하게 접근할 수 있다.<br/>

SMART 기법 <br/>
1) Specific(구체적)     	<br/>
2) Measurable(측정가능)  	<br/>
3) Attainable(달성가능)  	<br/>
4) Realistic(현실적)    	<br/>
5) Timely(기간)        	<br/>

이 후 목표를 정한 후 단위별로 나누어 테스트 케이스를 작성한다.

> **계산기 테스트 케이스** 			<br/>
> 1) 계산기 클래스 생성           		<br/>
> 2) 두개의 정수형인 입력값을 받는다.  <br/>
> 3) 더하기 기능을 제공한다.        <br/>
> 4) 빼기 기능을 제공한다.         <br/>
> 5) 나누기 기능을 제공한다.        <br/>
> 6) 곱셈 기능을 제공한다.         <br/>

1) 계산기 테스트 클래스를 생성한다. <br/>
   - 테스트 클래스의 클래스 명은 실제 구현할 클래스 뒤에 Test를 붙여 만든다. (암묵적인 규칙이다.)

```java
import org.junit.Test;

public class CalcurationTest {

    @Test
    public void test(){
    	Calcuration cal = new Calcuration();
    }
}
```

*'컴파일은 실패하지 않으면서 실행이 실패하는 정도로만 테스트 코드를 작성한다. '*

위의 코드는 실제 코드가 작성될 `Calcuration` 클래스를 생성하였다. <br/>
당연하지만 `Calcuration cal = new Calcuration();` 부분이 에러가 난다. 오류 해결을 위해 `Calcuration` 클래스 파일을 생성한다. <br/>
반드시 `Calcuration` 클래스 파일만 생성하자.(미리 앞서가서 메소드를 추가를 하면 안 된다.)<br/>
`Calcuration` 클래스를 생성한 후 테스트를 해보자. 테스트가 녹색 바가 나왔다면 테스트가 잘 진행되고 있다는 증거이다. 테스트 케이스에 체크 후 다음 단계를 진행하자.<br/>

> **계산기 테스트 케이스** 			<br/>
> ~~1) 계산기 클래스 생성~~           		<br/>
> 2) 두개의 정수형인 입력값을 받는다.  <br/>
> 3) 더하기 기능을 제공한다.        <br/>
> 4) 빼기 기능을 제공한다.         <br/>
> 5) 나누기 기능을 제공한다.        <br/>
> 6) 곱셈 기능을 제공한다.         <br/>

---

3) 두 개의 정수형인 입력값 받는다.

##### CalcurationTest.java
```java
import static org.junit.Assert.assertEquals;

import org.junit.Test;

public class CalcurationTest {
	
	@Test
	public void test(){
		int a = 1;
		int b = 2;
		
		Calcuration cal = new Calcuration(a, b);
		
		assertEquals("get a", 1, cal.getA(), 0);
		assertEquals("get b", 2, cal.getB(), 0);
	}
	
}
```

`Calcuration` 생성자에 정수 a와 b를 넘겨주고 get 메소드를 통해 입력 값이 잘 전달 됐는지 확인하는 테스트 코드이다. <br/>
정수 값 비교를 위해 `assertEquals` 메소드를 사용했고 사용법은  `assertEquals( 기대하는 값, 값, 오차범위);`이다.<br/>
테스트를 하면 당연히 실패이다. 실제코드에 생성자와 get 메소드를 추가하자.

##### Calcuration.java

``` java
package com.test.jUnitPratice.tddJunit;

public class Calcuration {
	
	int a;
	int b;
	
	public Calcuration(int a, int b) {
		this.a = a;
		this.b = b;
	}

	public int getA() {
		return a;
	}

	public int getB() {
		return b;
	}

}
```

*'TDD는 반드시 현재 실패하는 테스트 케이스를 통과할 정도로만 실제 코드에 작성한다.'*
실제 코드에 작성을 한 후 테스트를 진행해보자.
녹색 바가 나왔다. 다음단계를 진행하자.

> **계산기 테스트 케이스** 			<br/>
> ~~1) 계산기 클래스 생성~~        <br/>
> ~~2) 두개의 정수형인 입력값을 받는다.~~  <br/>
> 3) 더하기 기능을 제공한다.        <br/>
> 4) 빼기 기능을 제공한다.         <br/>
> 5) 나누기 기능을 제공한다.        <br/>
> 6) 곱셈 기능을 제공한다.         <br/>

3) 더하기 기능을 제공한다.

##### CalcurationTest.java
``` java
@Test
public void add(){
	int a = 1;
	int b = 2;
	
	int result = a + b;
	
	Calcuration cal = new Calcuration(a, b);
	
	assertEquals("더하기 테스트", result, cal.add());
}
```

실패하는 코드를 작성한다. 테스트를 통과하기 위해 실제코드에 add 메소드를 작성 후 다시 테스트를 진행해보자.<br/>
테스트가 성공적으로 진행됐다.

#### 자연스럽게 보이는 RGR 주기 (ClaenCode)

*'실패 -> 성공 -> 리펙토링  (RGR 주기)'*

더하기 기능만 추가했는데 벌써 중복된 코드가 보이기 시작한다. <br/>
테스트 코드를 리펙토링 후 테스트를 진행 해보자.

##### CalcurationTest.java
``` java
package com.test.jUnitPratice.tddJunit;

import static org.junit.Assert.assertEquals;
import org.junit.Test;

public class CalcurationTest {
	
	int a = 1;
	int b = 2;
	
	Calcuration cal = new Calcuration(a, b);
	
	@Test
	public void test(){
		assertEquals("get a", 1, cal.getA(), 0);
		assertEquals("get b", 2, cal.getB(), 0);
	}
	
	@Test
	public void add(){
		int result = a + b;
		assertEquals("더하기 테스트", result, cal.add());
	}
}
```

성공적으로 테스트가 진행됐다. `RGR` 주기에 의해 자연스레 코드베이스가 깔끔해지고 명확해진다.
이는 `TDD`의 `ClaenCode` 장점을 간접적이나마 느낄 수 있는 과정이다.

> **계산기 테스트 케이스** 			<br/>
> ~~1) 계산기 클래스 생성~~        <br/>
> ~~2) 두개의 정수형인 입력값을 받는다.~~  <br/>
> ~~3) 더하기 기능을 제공한다.~~        <br/>
> 4) 빼기 기능을 제공한다.         <br/>
> 5) 나누기 기능을 제공한다.        <br/>
> 6) 곱셈 기능을 제공한다.         <br/>


### 4 ~ 6단계도 마찬가지로 같은 과정을 지키면서 실제코드에 작성한다.

##### Calcuration.java
``` java
public class Calcuration {
	int a;
	int b;
	
	public Calcuration(int a, int b) {
		this.a = a;
		this.b = b;
	}

	public int add() { return a + b; }
	public int sub() { return a - b; }
	public int muliply() { return a * b; }
	public int division() { return a % b; }

	public int getA() {
		return a;
	}

	public int getB() {
		return b;
	}
}
```

##### CalcurationTest.java
``` java
import static org.junit.Assert.assertEquals;
import org.junit.Test;

public class CalcurationTest {
	
	int a = 1;
	int b = 2;
	
	Calcuration cal = new Calcuration(a, b);
	
	@Test
	public void test(){
		assertEquals("get a", 1, cal.getA(), 0);
		assertEquals("get b", 2, cal.getB(), 0);
	}
	
	@Test
	public void add(){
		int result = a + b;
		assertEquals("더하기 테스트", result, cal.add());
	}
	
	@Test
	public void sub(){
		int result = a - b;
		assertEquals("빼기 테스트", result, cal.sub());
	}
	
	@Test
	public void muliply(){
		int result = a * b;
		assertEquals("곱하기 테스트", result, cal.muliply());
	}
	
	@Test
	public void division(){
		int result = a % b;
		assertEquals("나누기 테스트", result, cal.division());
	}
}
```

### Goal?

> **계산기 테스트 케이스** 			<br/>
> ~~1) 계산기 클래스 생성~~        <br/>
> ~~2) 두개의 정수형인 입력값을 받는다.~~  <br/>
> ~~3) 더하기 기능을 제공한다.~~        <br/>
> ~~4) 빼기 기능을 제공한다.~~         <br/>
> ~~5) 나누기 기능을 제공한다.~~        <br/>
> ~~6) 곱셈 기능을 제공한다.~~         <br/>

테스트 케이스를 끝냈다. 과연 이걸로 완벽한 계산기라고 말할 수 있을까? 물론 완벽하지 않다.<br/>
예를 들어 입력 값이 null로 온다면 테스트는 실패한다.<br/>

> **7) 입력값이 없을땐 0으로 처리**        <br/>

테스트 케이스에 목록을 추가하여 프로그램을 보강하면 되지만 테스트 케이스를 작성시 개발자가 주관적인 생각으로 프로그램을 잤기 때문에 예외가 어디서 나타날지 모를 수 있다. 
기본적인 예외사항들은 `화이트 박스 검사`와 `블랙 박스 검사`를 통해 진행하면된다.


---


2) 정리하기

- 1) 계산기 객체 만들기
- 2) 더하기, 빼기, 나누기, 곱셈 메소드 생성하기

---

#### 마무리

여러 단위 테스트를 할 수 있는 `Library` 중에 `JUnit`을 선택한 이유는 <br/>
첫번째 나는 자바 개발자이기 때문이다. <br/>
두번째 `JUnit`은 `Java`의 테스트 `Library` 중 선두주자이기 때문이다. 5버전이 나온 이유다 <br/>.
세번째 `Spring boot`환경에서 `JUnit5`을 접목시켜 테스트 하는 방법이 최근에 나오기 시작했다. <br/>
마지막으론 기술 트렌드를 놓치고 싶지 않기 위함이다.

_추후 `Spring boot`에서 `JUnit5`을 접목시켜 테스트 하는 방법을 작성할 계획이다._ <br/>

---
