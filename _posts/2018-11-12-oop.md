---
layout: post
title: "OOP에 대해 말해주세요"
tags: [OO, OOP, Class-based programming, Prototype-based programming]
categories: [OO]
subtitle: "OOP에 대한 고찰"
feature-img: "md/img/thumbnail/oop.png"
thumbnail: "md/img/thumbnail/oop.png"
excerpt_separator: <!--more-->
sitemap:
display: "false"
changefreq: daily
priority: 1.0
---

<!--more-->

# OOP에 대한 고찰

---

OOP 혹은 객체지향 프로그래밍이라는 단어는 개발자라면 수도 없이 들었던 단어이다. 특히 신입 개발자 대상으로 자주 나오는 질문 중 하나로써 개발자가 OOP라는 개념에 대해 얼마만큼 인지하고 있는지에 대해 중요시 여겨지고 있다.

 이를 입증하듯 대부분의 대형 프로젝트에선 OOP를 사용하며 개발을 하고 있고 이는 OOP가 개발의 효과적인 프로그래밍이라는 것을 입증하는 동시에 하나의 대표적인 프로그래밍의 패러다임으로써 자리매김했다는 뜻이기도 한다.

이처럼 OOP의 개념을 인지하는 것은 매우 중요하다. 하지만 나는 “OOP를 이해하고 개발을 하나요?”라는 물음에 선뜻 말할 수 없었다. 본 포스팅을 통해 OOP에 대해 다시 한번 더 정리하는 시간을 가지려 한다.

---

### 객체지향(OO, Object-Oriented)

OOP는 Object-Oriented Programming의 약자로 객체지향 프로그래밍이라고 부른다. 이처럼 OOP에 대해 알기 위해선 "객체지향"이라는 개념은 매우 중요하다.

그렇다면 "객체지향"이란 무엇일까? 먼저 사전적 의미를 찾아보자.

- 객체(客體) : 작용의 대상이 되는 쪽.
- 지향(指向) : 정해지거나 작정한 방향으로 나가는 것. 또는, 그 방향.

![img](/md/img/oop/oo1.png "Object-Oriented")

이 사전적인 의미로 빗대어 보면 **"객체를 추구한다."**이라는 의미와 가깝다.

하지만 영어로 명명된 용어를 단순히 직역하며 해석하는 데 있어 기술 용어에 대해 잘못 해석하는 경우가 생기거나 무엇보다 기술에 대해 이해하는 데 있어 어려움이 생긴다. 이 때문에 -Oriented의 의미에 대해 다시 확인해 볼 필요가 있다.

<img src="/md/img/oop/oo2.png" style="max-height: none;">

영어 사전에 정의된 **-Oriented**는 "방향성"의 의미가 아닌, "위주" 혹은 "주된"이라는 의미에 가깝다.

- 객체(客體) : ~~작용의 대상이 되는 쪽.~~<br/>
	→ 객관적으로 존재하는 실체
- 지향(指向) : ~~정해지거나 작정한 방향으로 나가는 것. 또는, 그 방향.~~<br/>
	→ 위주, 주된

즉 객체지향은 "객체 추구" 보다는 "객체 위주"가 더 적합하다. 따라서 OOP는 "객체 위주로 프로그램하다."로 정의할 수 있다.

그렇다면 객체는 무슨 의미일까?

### 객체(Object)

 객체(Object)는 실제 세계에 존재하는 모든 것들을 망라한다.

![img](/md/img/oop/object.png "Object")

예를 들어 자판기 프로그램을 만든다고 가정해보자.

이때 객체의 예로는 음료수 종류부터 판매 금액, 사용자의 금액, 제품 수, 그리고 사용자 돈을 넣는 행위, 음료수를 뽑아 먹기 위한 과정과 동작까지 그 외 모든 것들을 망라한다. 즉 프로그래밍에서 객체의 의미는 프로그램을 구성하는 단위 중 하나이며, 그것의 논리적인 의미는 우리가 일상에서 접하는 객체와 유사하다.

![img](/md/img/oop/object2.png "Object")

 정리하자면 객체의 원형, 즉 클래스 기반 언어에서는 클래스라는 틀 안에 프로그램에 필요한 데이터(실체)와 그 데이터에 관련되는 동작(절차, 방법, 기능)을 모두 포함한 개념이다.

  이 때문에 OOP로 프로그램을 만든다는 의미는 객체들을 만든다는 의미와 같고, 더 나아가 OOP는 객체를 만드는 것부터 시작된다고 해석할 수 있다. 이제 자세히, 그리고 본격적으로 OOP에 대해 알아보자.

### 객체 지향 프로그래밍(OOP, Object-Oriented Programming)

![img](/md/img/oop/object-oriented-programming.png "Object-Oriented Programming")

OOP는 컴퓨터 프로그래밍의 하나의 패러다임으로써, 실제 세계에 기반을 둔 모델을 모듈화하기 위해 추상화를 사용하는 프로그래밍 패러다임이다.

이 패러다임은 논리적인 수행을 중심으로 개발하였던 전통적인 소프트웨어의 개발 방식을 완전히 새로운 시각으로 바라본 혁명적인 개념으로써 동작보다는 객체, 논리보다는 자료를 바탕으로 구성한다. 즉 논리적인 데이터를 실제 프로그램에서 다뤄질 물리적인 데이터로 변환하고, 이 물리적인 데이터를 통상 객체라 칭해 이 객체를 사용하는 개발하는 방식을 취한다.

여기까지 OOP에 대한 정의다. 나름 전문적인 용어들을 나열하여, 흔히 아는 체 좀 해봤다. 물론 OOP에 대해 처음 알게 된 사람이라면 이해하기 어렵지만, 앞으로 설명을 통해 이해를 하지 못 했던 부분이 해결될 거라 믿는다.

먼저 기술에 대해 숙련하기 위해선 그 기술이 등장한 배경에 대해 알아봐야 한다. 우리는 OOP를 알기 위해선 OOP의 등장 배경을 알아야 한다.

### OOP의 탄생 - 전통적인 프로그래밍의 회고

기존의 전통적인 소프트웨어는 논리적인 수행, 즉 입력을 받아 처리한 다음, 결과를 내는 것이라는 생각이 지배적이었다. 또한 프로그래밍한다는 것은 "어떻게 자료를 정의할까" 보다는 어떻게 논리를 써나가는 것인가로 간주하였다.

이러한 전통적인 프로그래밍은 필요한 기능들을 함수로 만들고 그 함수에 필요한 입력은 반드시 전역이나 전달 인자로 정의했다. 이는 수직적인 구조를 갖게 되는 동시에 데이터는 자연스럽게 위에서 아래로 전달하는 전통적인 제어 흐름으로 설계된다.

이 프로그래밍을 절차적 프로그래밍이라 하고, 이 절차적 프로그래밍으로 개발된 소프트웨어는 개발 속도가 빠를 뿐만 아니라, 프로세스가 명확하고 처리속도가 빨랐다.

하지만 "하나의 기능에 하나의 프로세스"라는 고질적인 특성은 대규모 프로젝트에선 오히려 독이었다. 기능 수정과 사용자의 잦은 요구 사항은 기능의 재설계로 직결되었고 이를 해결하기 위해선 기능의 전체적인 설계를 파악해야만 했다.

결과적으로 프로젝트 버퍼(Project buffer)가 대부분 개발 기간으로 소진되었고, 종종 기능 일부분을 수정하기 위해선 전체적인 설계를 수정해야 하는 경우가 발생했다. 이러한 절차지향 개발 방식의 회고들은 개발자들에게 고찰하는 계기가 되었다.

이를 통해 소프트웨어에서 논리보다는 오히려 다루고자 하는 객체가 중요하다는 결론을 다다르게 되었고 이를 바탕으로 절차적 프로그래밍에 객체라는 개념을 포함한 OOP라는 새로운 프로그래밍의 패러다임이 등장했다.

### 자료 추상화(Data Abstraction)

절차보다는 객체를 중심으로 프로그래밍하는 OOP는 절차적 프로그래밍과 개발하는 방식이 다르다. 절차적 프로그래밍은 논리적인 순서를 우선시했다면 OOP를 실현하기 위해 가장 먼저 해야 할 단계는 자료 추상화이다.

 자료의 추상화란 하나의 논리(기능)를 독립적인 모듈로 보기 위해 구체적인 자료형 혹은 구조를 만드는 일련의 과정을 뜻한다.

이 과정은 프로그램에서 다뤄질 물리적인 데이터를 만들기 위해 논리적인 데이터들의 상호 간의 어떠한 연관성이 있는지 식별하고 관계를 맺는 작업을 한다. 이러한 작업을 추상화라 하고 흔히 데이터 모델링이라는 작업이 이와 같다.

일단 모든 논리적인 데이터를 물리적인 데이터로 추상화했다면, 이 물리적 데이터는 객체 클래스로 일반화하고 이 클래스가 담고 있는 속성과 행위를 데이터의 종류와 그것을 다룰 수 있는 모든 논리 순서로 인스턴스 한다.

인스턴스한 데이터 종류와 논리순서는 변수와 메소드라 부르고 이러한 클래스의 실제 인스턴스 하나를 상황에 따라 "객체" 또는 "클래스 활성체"라 한다. 객체 또는 활성체는 실제 프로그램에서 다뤄질 데이터로써 정의한한다. 일반적으로 메소드는 수행할 명령어를 규정하고, 변수는 객체와 관련한 데이터를 규정한다.

### 추상화에 대한 착각

 자료 추상화는 객체를 만들기 위한 과정으로 OOP의 필수적인 과정이다. 하지만 많은 개발자는 자료 추상화에 대해 어려워한다. 이러한 생각은 예술 세계에서의 추상화와 프로그래밍의 추상화의 의미의 차이가 있다는 착각에 비롯된다.

![img](/md/img/oop/picasso.png "화가와 바느질하는 모델")





###   OOP의 제어 흐름 그리고 제어의 역전

앞서 설명한 OOP 객체 정의하는 일련의 과정들은 자연스레 절차적 프로그래밍과의 제어흐름의 차이를 만든다. 이 제어흐름의 차이는 데이터의 소유(Own)와 조작(Manipulation)에 대한 개념에 있다.

단편적인 예로, 객체 지향 언어 이전에 절차적 언어들을 통해 개발 했었는데 대표적으로 Pascal, C가 이에 해당한다.

이 절차적 언어들은 프로그램의 기능을 함수안에 정의했고, 정의된 함수에 필요한 입력은 반드시 전역이나 전달인자로 전했다. 이 때문에 함수를 사용하기 위해선 반드시 누군가가 호출해줘야 하고 제어의 흐름이 위에서 아래로, 즉 전통적인 수직적인 제어흐름을 갖게 되었다.

하지만 OOP는 자료의 소유 , 생성이 각 객체에 의해서 알아서 되고 추상적 설계를 통해서 기능이 실행될 때 실제 실행될 코드가 나중에 결정된다. 이를 IoC (Inversion of Control)라하고 흔히 제어의 역전이라고 불린다.

``` java
public void showMeTheCan(){
  String    drink       = "콜라";	// 음료종류
  int       userAmt     = 1000;		// 사용자금액
  int       resultAmt   = 0;		// 반환금액

  // 음료 금액
  int cola  = 1500;
  int cider = 1000;

  switch (drink) {
    case "콜라":
      resultAmt = userAmt - cola;
    break;

    case "사이다":
      resultAmt = userAmt - cider;
    break;
  }

  if(resultAmt < 0){
    System.out.println("금액이 부족합니다.");
  }else{
    System.out.println("반환 금액은 " + resultAmt);
  }
}
```


```
public class VendingMachineOOP {
	Drink drink = new Cola();

	@Test
	public void test(){
		setAmt(drink, 2000);
	}

	public void setAmt(Drink drink, int inputAmt){
		selectDrink(drink, inputAmt);
	}

	public void selectDrink(Drink drink, int inputAmt){
		int resultAmt = 0;
		int drinkAmt = drink.getAmt(); // 음료 금액
		resultAmt = inputAmt - drinkAmt;
		validationAmt(resultAmt);
	}

	public void validationAmt(int resultAmt){
		if(resultAmt < 0){
			System.out.println("금액이 부족합니다.");
		}else{
			getReturnAmt(resultAmt);
		}
	}

	public void getReturnAmt(int resultAmt){
		System.out.println("반환 금액은 " + resultAmt);
	}

	class Cola implements Drink{
		@Override
		public String getName() {
			return "콜라";
		}
		@Override
		public int getAmt() {
			return 1500;
		}
	}

	public interface Drink {
		public String getName();
		public int    getAmt();
	}

}

```
결과적으로 순차적으로 실행되는 코드의 위에서 아래의 코드로 어떤 값을 넘기거나 코드의 실행순서를 결정하지 않아도 되고  각 모듈/클래스 별로 정의된 기능이 실행된다.

### OOP의 이점

 OOP는 모든 객체를 모듈화하여 유연하고 유지 보수성이 높은 프로그래밍을 할 수 있도록 의도 되었다.

추상화를 사용하여 객체를 모듈화하는 과정은 추상적 설계를 하도록 유도되었고, 동시에 인터페이스 기반의 설계가 되었다.  모듈의 재사용성을 증가시키고 체계적이고 효율적으로 코드를 관리할 수 있게 되었다.

 결과적으로 추상화 클래스를 통해 객체를 재사용한다는 원초적인 원칙을 통해 코드를 간단하고, 명료하고, 효율적으로 관리할 수 있다.

### OOP의 특징

OOP의 특징엔 캡추다산정이 불리는 캡슐화, 추상화, 다형성, 상속성, 정보 은닉이 있다.

- Encapsulation(캡슐화)
- Abstract(추상화)
- Polymorphism(다형성)
- Inheritance(상속성)
- Information hiding(정보 은닉)

#### Encapsulation(캡슐화)

캡슐화라는 단어를 생각하면 알약을 떠올릴 수 있다.

알약은 하나의 틀안에 여러 성분이 포함되어있는데 이와 마찬가지로 OOP의 캡슐화를 생각하면 되겠다.


캡슐화는 객체 지향 프로그래밍에서 다음 2가지 측면이 있다.

1. 객체의 속성(data fields)과 행위(메서드, methods)를 하나로 묶고
2. 실제 구현 내용 일부를 외부에 감추어 은닉한다.

속성인 데이터와 메서드의 결합은 C++의 경우 멤버함수를 호출할 때 객체의 저장공간을 멤버함수에 넘겨 데이터 처리를 하도록 하는 방법을 사용한다.

외부에 감추는 방법으로는 언어적 측면에서 접근지정자를 두어 은닉의 정도를 기술하여 구현한다. 은닉의 정도를 접근지정자로 기술하고 해당 영역에 들어가는 속성이나 메서드를 제한하면 된다. 접근지정자에 의해 제한된 멤버들은 컴파일러에 의해 판단된다. 언어적 측면에서 접근지정자에 의해 정의된 해당 멤버변수나 멤버함수는 코드 중에 접근방식을 위반한 코드를 작성하면 컴파일 오류로 처리하고 실행코드 생성을 제한한다.

##### 접근제한자

- private : 자기 클래스 내부의 메서드에서만 접근 허용
- protected : 자기 클래스 내부 또는 상속받은 자식 클래스에서 접근 허용
- public : 모든 접근을 허용한다.

---

캡슐화란 관련된 데이터와 알고리즘(코드)이 하나의 묶음으로 정리된 것으로써 개발자가 만들었으며, 관련된 코드와 데이터가 묶여있고 오류가 없어 사용이 편리합니다. 데이터를 감추고 외부 세계와의 상호작용은 메소드를 통하는 방법인데, 라이브러리로 만들어 업그레이드하면 쉽게 바꿀 수 있습니다.

※ 메소드 : 메시지에 따라 실행시킬 프로시저로서 객체지향 언어에서 사용되는 것. 객체지향 언어에서는 메시지를 보내 메소드를 수행시킴으로써 통신(communication)을 수행한다.

Information hiding

---

객체의 상세한 내용을 객체 외부에 철저히 숨기고 단순히 메시지만으로 객체와의 상호작용을 하게 하는 것을 캡슐화(encapsulation)라고 한다. 정보 은닉(information hiding)이라는 표현으로 설명하기도 하는데 추상화와 동일한 개념이다. 캡슐화는 추상화와 거의 같은 개념이지만 추상화를 지원하며 보다 구체적이고 제한적이라고 할 수 있다.

예를 들면, 클래스를 선언하고 그 클래스를 구성하는 객체에 대하여 "public" 또는 "private" 등으로 정의해준다. 이렇게 되면 "public"으로 정의된 함수 또는 데이터는 외부에서 사용이 가능하며, "private"으로 선언된 경우는 외부에서 제어할 수 없고 내부에서만 사용된다.

이것은 클래스 외부에는 제한된 접근 권한을 제공하며 원하지 않는 외부의 접근에 대해 내부를 보호하는 작용을 한다. 이렇게 함으로써 이들 부분이 프로그램의 다른 부분들에 영향을 미치지 않고 변경될 수 있다.

출처: http://tenlie10.tistory.com/1 [게임 개발자 블로그]

#### Abstract(추상화)

유념해야할 부분은 추상화와 자료의추상화는 다른개념이야

 간단히 예를 들자면 추상화라는건 클래스의 설계를 위해서 상속관계/구현 등의 구조를 관계가 느슨하도록 만들면서도 서로 강하게 연결되도록 구조화시키는데 쓰이는 개념이지

 그렇다면 클래스 기반의 언어에서는 추상화를 쓸 수 있다는거네요? 자료의 추상화를 자료를 은닉시키고 상속관계하에서 접근을 제한/허용하는 등의 접근체계를 만드는 개념이지 추상화는 설계의 개념이야

꼭 클래스 기반언어에서만 쓰이는게 아니지  C언어는 추상화 못하나?

굳이 의미를 부여하자면 Module 기반 언어지

---

#### Polymorphism(다형성)

셋째, 다형성이 있습니다. 다형성이란 하나의 이름(방법)으로 많은 상황에 대처하는 기법입니다. 개념적으로 동일한 작업을 하는 함수들에 똑같은 이름을 부여할 수 있으므로 코드가 더 간단해지는 효과가 있습니다.

#### Inheritance(상속성)

둘째, 상속이 있습니다. 상속은 이미 작성된 클래스를 이어 받아서 새로운 클래스를 생성하는 기법으로 위에서 말한 기존 코드를 재활용해서 사용하는 것을 의미합니다. 객체지향 방법의 큰 장점중 하나입니다.

#### Information hiding(정보 은닉)


위의 특성들로 인해 생기는 객체지향 방법의 장점은 다음과 같습니다.

 신뢰성 있는 소프트웨어를 쉽게 작성할 수 있다. (개발자가 만든 데이터를 사용하기에 신뢰할 수 있다.)
 코드를 재사용하기 쉽다.
 업그레이드가 쉽다.
 디버깅이 쉽다.

 객체의 상세한 내용을 객체 외부에 철저히 숨기고 단순히 메시지만으로 객체와의 상호작용을 하게 하는 것을 캡슐화(encapsulation)라고 한다. 정보 은닉(information hiding)이라는 표현으로 설명하기도 하는데 추상화와 동일한 개념이다. 캡슐화는 추상화와 거의 같은 개념이지만 추상화를 지원하며 보다 구체적이고 제한적이라고 할 수 있다.

 예를 들면, 클래스를 선언하고 그 클래스를 구성하는 객체에 대하여 "public" 또는 "private" 등으로 정의해준다. 이렇게 되면 "public"으로 정의된 함수 또는 데이터는 외부에서 사용이 가능하며, "private"으로 선언된 경우는 외부에서 제어할 수 없고 내부에서만 사용된다.

 이것은 클래스 외부에는 제한된 접근 권한을 제공하며 원하지 않는 외부의 접근에 대해 내부를 보호하는 작용을 한다. 이렇게 함으로써 이들 부분이 프로그램의 다른 부분들에 영향을 미치지 않고 변경될 수 있다.

  ---


 3. 상속(Inheritance)



 상속은 클래스의 속성과 행위를 하위 클래스에 물려주거나, 상위 클래스에서 물려받는 것을 지칭한다.



 *상속을 사용하면 좋은점은?



 재사용으로 인한 코드가 줄어든다. 하위 클래스에서 속성이나 행위를 다시 정의하지 않고 상속 받아서 사용함으로써 코드가 줄어든다.
 좀 더 범용성 있게 사용할 수 있다. 예를 들어 Object타입의 매개변수에는 String타입이나 int타입의 객체가 쓰여도 문제되지 않는다. 왜냐하면 String과 int타입 모두 Object타입의 객체를 상속받은 하위 클래스이기 때문이다.


 참고로 하위 클래스는 상위 클래스가 가지고 있는 모든 자료와 메소드를 물려받아 자유롭게 사용할 수 있지만, 또한 자신만의 자료와 메소드를 추가적으로 덧붙임으로써 새로운 형태의 클래스로 발전할 수 있다.



 4. 다형성(Polymorphism)



 다형성은 객체지향의 개념에서 가장 중요한 특징이라고 말할 수 있다. 다형성이란 사전적 의미로 '다양한 형태로 나타날 수 있는 능력'을 뜻한다.



 객체지향 프로그래밍은 하나의 클래스 내부에 같은 이름의 행위를 여럿 정의하거나, 상위 클래스의 오퍼레이션을 하위 클래스에서 다시 정의하여 사용할 수 있기 때문에 바로 이 다형성이라는 특징을 갖는 것이다.


### 객체지향의 5원칙

#### SRP : 단일 책임 원칙


#### OCP : 개방-폐쇄 원칙


#### LSP : 리스코프 치환 원칙


#### ISP : 인터페이스 분리 원칙


#### DIP : 의존성 역전 원칙


### 마무리

OOP의 등장 배경을 설명하기 전에 새로운 기술이 나오는 이유에 대한 주관적인 생각을 말해보려 한다.

개발자들은 태생적으로 게으른 존재고 현재 기술이 비효율적이라고 생각이 들면 자연스레 효과적인 해결 방안을 제시하고 이를 바탕으로 새로운 기술이 나타난다. 이를 근거로 객체의 사용에 대한 물음에 대해 기존의 전통적인 소프트웨어의 개발 방식에서 답을 찾아보려 한다.

앞서 설명을 통해 OOP라는 개념을 처음 알게 되었을진 몰라도 우리는 능숙하게 OOP를 하며 개발하고 있다. 흔히 우리가 사용했던 JAVA가 바로 대표적인 객체지향 언어로 클래스, 메소드, 변수를 사용하며 개발하기 때문이다.


---

### 참고


[나무위키 - 객체지향의 5대 원칙](https://namu.wiki/w/%EA%B0%9D%EC%B2%B4%20%EC%A7%80%ED%96%A5%20%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/%EC%9B%90%EC%B9%99)

 [OOP 객체지향 프로그래밍](http://www.terms.co.kr/OOP.htm)

 [[Java] OOP(객체지향 프로그래밍)의 특징](https://gmlwjd9405.github.io/2018/07/05/oop-features.html)


 [OOP 탄생배경](https://m.blog.naver.com/PostView.nhn?blogId=ghen4268&logNo=110184188778&proxyReferer=https%3A%2F%2Fwww.google.com%2F)

 [OOP 등장 배경, 기본 개념, 특징](https://m.blog.naver.com/PostView.nhn?blogId=mhg1186&logNo=220661553978&proxyReferer=https%3A%2F%2Fwww.google.com%2F)

 [버퍼](http://www.jidum.com/jidums/view.do?jidumId=391)

 [캡슐화는 정보 숨김이 아닙니다.](https://www.javaworld.com/article/2075271/core-java/encapsulation-is-not-information-hiding.html)

[캡슐화(encapsulation)이란?](http://blog.naver.com/PostView.nhn?blogId=netrance&logNo=110096417364)
