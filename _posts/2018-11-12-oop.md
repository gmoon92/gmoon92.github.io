---
layout: post
title: "OOP에 대해 말해주세요"
tags: [OO, OOP, Class-based programming, Prototype-based programming]
categories: [OO]
subtitle: "OOP에 대한 고찰"
feature-img: "md/img/thumbnail/oop.png"
thumbnail: "md/img/thumbnail/oop.png"
excerpt_separator: <!--more-->
sitemap:
display: "false"
changefreq: daily
priority: 1.0
---

<!--more-->

# OOP에 대한 고찰

### 객체지향(OO, Object-Oriented)

OOP는 Object-Oriented Programming의 약자로 객체지향 프로그래밍이라고 부른다. 이처럼 OOP에 대해 알기 위해선 "객체지향"이라는 개념은 매우 중요하다.

그렇다면 "객체지향"이란 무엇일까? 먼저 사전적 의미를 찾아보자.

- 객체(客體) : 작용의 대상이 되는 쪽.
- 지향(指向) : 정해지거나 작정한 방향으로 나가는 것. 또는, 그 방향.

![img](/md/img/oop/oo1.png "Object-Oriented")

이 사전적인 의미로 빗대어 보면 **"객체를 추구한다."**이라는 의미와 가깝다.

하지만 영어로 명명된 용어를 단순히 직역하며 해석하는 데 있어 기술 용어에 대해 잘못 해석하는 경우가 생기거나 무엇보다 기술에 대해 이해하는 데 있어 어려움이 생긴다. 이 때문에 -Oriented의 의미에 대해 다시 확인해 볼 필요가 있다.

<img src="/md/img/oop/oo2.png" style="max-height: none;">

영어 사전에 정의된 **-Oriented**는 "방향성"의 의미가 아닌, "위주" 혹은 "주된"이라는 의미에 가깝다.

- 객체(客體) : ~~작용의 대상이 되는 쪽.~~<br/>
	→ 객관적으로 존재하는 실체
- 지향(指向) : ~~정해지거나 작정한 방향으로 나가는 것. 또는, 그 방향.~~<br/>
	→ 위주, 주된

 정리하자면 객체지향은 "객체 추구" 보다는 "객체 위주"가 더 적합하다. 따라서 OOP는 "객체 위주로 프로그램하다."로 정의할 수 있다. 하지만 객체라는 개념을 모르는 분들은 OOP의 정의가 오히려 혼란스러울 수 있다. 주제에 벗어나지만, 객체라는 개념에 대해 살펴볼 필요가 있다.

### 객체(Object) - 객관적으로 존재하는 실체

프로그래밍에서 객체(Object)의 의미는 프로그램을 구성하는 단위 중 하나로써 메모리에 할당된 공간을 의미한다. 이 객체의 논리적인 의미는 우리가 일상에서 접하는 객체와 유사하다.

![img](/md/img/oop/object.png "Object")

실제 세계의 자판기 프로세스를 빗대어 보면 다음과 같은 프로세스를 지니고 있다.

 1. 금액을 넣는다,
 2. 음료수를 선택한다.
 3. 자판기는 음료수와 잔돈을 반환해준다.

이때 객체는 작은 버튼과 같은 작은 단위부터 사용자의 금액, 음료수 종류, 판매 금액 그리고 사용자 돈을 넣는 행위, 자판기가 돈을 검사하고 돈을 반환하는 과정 그 외 실제 세계의 모든 것들을 망라한다.

![img](/md/img/oop/object2.png "Object")

앞서 정의한 모든 객체를 프로그램에서 필요한 데이터를 만들기 위해 불필요한 객체는 식별하는 작업을 한다. 이러한 작업을 추상화라 하고 식별한 객체들은 OOP에선 속성(Attribute)과 행위(Behavior)로 구분한다. 정리하자면 사용자의 금액, 음료수를 속성으로 간주하여 변수로 지정하고 사용자가 돈을 넣는 행위 그 외 모든 논리적인 동작들을 메소드로 정의한다.

- Attribute(Properties) : 데이터 타입(변수, 참조할 클래스(클래스의 실체))
- Behavior(Operation) : 데이터의 동작 방식 정의(메소드)

<img src="/md/img/oop/object3.png" style="max-height: none;">

  즉 객체란 클래스의 인스턴스로써 클래스라는 틀 안에 메모리에 할당된 실체, 즉 프로그램에 필요한 데이터와 그 데이터에 관련되는 동작을 모두 포함한 개념이다. 이 때문에 OOP로 프로그램을 만든다는 의미는 객체들을 만든다는 의미와 같고, 더 나아가 OOP는 객체를 만드는 것부터 시작된다고 해석할 수 있다. 이제 본격적으로 OOP에 대해 알아보자.

### 객체 지향 프로그래밍(OOP, Object-Oriented Programming)

![img](/md/img/oop/object-oriented-programming.png "Object-Oriented Programming")

OOP는 컴퓨터 프로그래밍의 하나의 패러다임으로써, 실제 세계에 기반을 둔 모델을 모듈화하기 위해 추상화를 사용하는 프로그래밍 패러다임이다.

이 패러다임은 논리적인 수행을 중심으로 개발하였던 전통적인 소프트웨어의 개발 방식을 완전히 새로운 시각으로 바라본 혁명적인 개념으로써 동작보다는 객체, 논리보다는 자료를 바탕으로 구성한다. 즉 논리적인 데이터를 실제 프로그램에서 다뤄질 물리적인 데이터로 변환하고, 이 물리적인 데이터를 추상화를 통해 객체로 구성하고 이 객체를 사용하는 개발하는 방식을 취한다. 이러한 개발 방식의 변화는 무엇보다 전통적인 소프트웨어의 개발 방식의 회고로부터 시작되었다.

### OOP의 탄생 - 전통적인 프로그래밍의 회고

기존의 전통적인 소프트웨어는 논리적인 수행, 즉 입력을 받아 처리한 다음, 결과를 내는 것이라는 생각이 지배적이었다. 또한, 프로그래밍한다는 것은 "어떻게 자료를 정의할까" 보다는 어떻게 논리를 써나가는 것인가로 간주하였다.

<img src="/md/img/oop/procedural-flow.png" style="max-height: none;">

이러한 전통적인 프로그래밍은 필요한 기능들을 함수로 만들고 그 함수에 필요한 입력은 반드시 전역이나 전달 인자로 정의했다. 이는 수직적인 구조를 갖게 되는 동시에 데이터는 자연스럽게 위에서 아래로 전달하는 전통적인 제어 흐름으로 설계된다.

이 프로그래밍을 절차적 프로그래밍이라 하고, 이 절차적 프로그래밍으로 개발된 소프트웨어는 개발 속도가 빠를 뿐만 아니라, 프로세스가 명확하고 처리속도가 빨랐다. 하지만 "하나의 기능에 하나의 프로세스"라는 고질적인 특성은 대규모 프로젝트에선 오히려 독이었다. 기능 수정과 사용자의 잦은 요구 사항은 기능의 재설계로 직결되었고 이를 해결하기 위해선 기능의 전체적인 설계를 파악해야만 했다.

결과적으로 프로젝트 버퍼(Project buffer)가 대부분 개발 기간으로 소진되고, 종종 기능 일부분을 수정하기 위해선 전체적인 설계를 수정해야 하는 경우가 발생했다. 이러한 절차지향 개발 방식의 회고들은 개발자들에게 고찰하는 계기가 되었다. 이를 통해 소프트웨어에서 논리보다는 오히려 다루고자 하는 객체가 중요하다는 결론을 다다르게 되었고 이를 바탕으로 절차적 프로그래밍에 객체라는 개념을 포함한 OOP라는 새로운 프로그래밍의 패러다임이 등장했다.

이처럼 절차적 프로그래밍과 OOP의 프로그램에 대한 관점이 다른 것처럼 개발하는 방식 또한 다르다. 절차적 프로그래밍은 논리적인 순서를 우선시했다면 OOP를 실현하기 위해 가장 먼저 해야 할 단계는 자료 추상화이다.

### 자료 추상화(Data Abstraction)

 자료의 추상화란 하나의 논리(기능)를 독립적인 모듈로 보기 위해 구체적인 자료형 혹은 구조를 만드는 일련의 과정을 뜻한다.

 이 과정은 프로그램에서 다뤄질 물리적인 데이터를 만들기 위해 논리적인 데이터들의 상호 간의 어떠한 연관성이 있는지 식별하고 관계를 맺는 작업을 한다. 이러한 작업을 추상화라 하고 흔히 데이터 모델링이라는 작업이 이와 같다. 일단 모든 논리적인 데이터를 물리적인 데이터로 추상화했다면, 이 물리적 데이터는 객체 클래스로 일반화하고 이 클래스가 담고 있는 속성과 행위를 데이터의 종류와 그것을 다룰 수 있는 모든 논리 순서로 인스턴스 한다.

인스턴스한 데이터 종류와 논리순서는 변수와 메소드라 부르고 이러한 클래스의 실제 인스턴스 하나를 상황에 따라 "객체" 또는 "클래스 활성체"라 한다. 객체 또는 활성체는 실제 프로그램에서 다뤄질 데이터로써 정의한다. 일반적으로 메소드는 수행할 명령어를 규정하고, 변수는 객체와 관련한 데이터로 규정한다.

#### 추상화에 대한 착각

이처럼 자료 추상화는 객체를 만들기 위한 과정으로 OOP의 필수적인 과정이다. 하지만 많은 개발자는 자료 추상화에 대해 어려워한다. 이러한 생각은 예술 세계에서의 추상화와 프로그래밍의 추상화의 의미의 차이가 있다는 착각에 비롯된다.

![img](/md/img/oop/picasso.png "화가와 바느질하는 모델")

다음의 그림은 추상화의 거장 피카소의 "화가와 바느질하는 모델"이라는 작품이다.

여기서 주의 깊게 봐야 할 점은 그림 속 캔버스이다. 얼핏 보면 기괴한 낙서를 그린 것은 아닌지 생각할 수도 있다. 하지만 이것이 바로 추상화다. 그림 속 화가는 모델을 그린 것이 아닌 바느질하는 손동작을 묘사하기 위해 직선과 곡선이라는 표현 방식으로 추상화한 그림이다.

프로그래밍도 마찬가지다. 실제 세계의 모듈을 프로그램에서 다뤄질 데이터들을 만들기 위해 객체라는 표현 방식으로 추상화한다고 생각하면 편하다.

###   OOP의 제어 흐름 그리고 제어의 역전

앞서 설명한 자료의 추상화의 과정은 자연스레 절차적 프로그래밍과의 제어흐름의 차이를 만든다. 이 제어흐름의 차이는 데이터의 소유(Own)와 조작(Manipulation)에 대한 개념에 있다.

이해를 돕기 위해 앞서 설명한 자판기의 프로세스를 가지고 비교를 해보려 한다.

1. 금액과 음료수를 입력한다.
2. 음료수의 금액을 확인한다.
3. 음료수 재고 돈을 계산한다.
4. 자판기는 음료수와 잔돈을 반환한다.

먼저 절차적 프로그래밍의 코드는 다음과 같다.

``` javascript
function inputInfo(userAmt, drink) {
  // TODO step1 금액과 음료수를 입력한다.
  choiceDrink(userAmt, drink);
}

function choiceDrink(userAmt, drink) {
  // TODO step2 음료수의 금액을 확인한다.
  calculate(userAmt, drink, drinkAmt);
}

function calculate(userAmt, drink, drinkAmt){
  // TODO step3 음료수 재고와 돈을 계산한다.
  resultAction(drink, userAmt);
}

function resultAction(userAmt, drink) {
  // TODO step4 자판기는 음료수와 잔돈을 반환한다.
}
```

보다시피 하나의 동작을 하나의 함수로 정의했고, 코드는 논리적인 순서가 중점으로 작성되었다.

이러한 프로그래밍의 데이터는 함수라는 단위로 식별하여 각 기능을 제어한다. 이 말인즉슨 함수 하나의 함수마다 데이터의 소유와 조작이 각 함수의 안의 범위에서 제한적이라는 의미로써 데이터의 소유권을 다음 함수에 전달하기 위해선 전역 변수 또는 전달 인자로 전달해야만 했다.

즉 함수에 필요한 데이터는 전역변수 또는 매개 변수를 통해 데이터의 소유 범위를 정하고 이러한 제어 흐름은 함수 간 강한 의존성을 띄고, 이로 인해 기능의 순서가 바뀌는 경우엔 결괏값을 보장할 수 없게 된다.

특히 결괏값을 추출하기 위한 과정에서, 데이터 조작은 프로그래밍에 있어 개발자에게 데이터 제어권을 부여한다. 데이터 조작은 일반적으로 분기문 또는 반목문을 통해 이뤄지는데 이러한 제어가 많아질수록 개발자에게 부담된다.

``` javascript
function choiceDrink(userAmt, drink) {
  // TODO step2 음료수의 금액을 확인한다.
  var drinkAmt = 0;

  switch (drink) {
    case "콜라":
      drinkAmt = 1500;
    break;

    case "사이다":
      drinkAmt = 1000;
    break;
  }
  calculate(userAmt, drink, drinkAmt);
}
```

다음의 `choiceDrink()` 함수 코드를 보면 switch 분기문을 통해 `drinkAmt`의 데이터가 조작된다는 걸 알 수 있다. 다음 코드는 별문제가 없어 보이지만 "환타"라는 음료수가 추가하자는 요구사항이 왔다면 전체 코드에서 해당 음료수를 조작하는 함수를 찾아 환타라는 조건을 추가하고, 이전 함수와 이후 함수에 데이터에 영향을 미치진 않는지 검증을 해야 한다.

검증하는 도중에 오류가 발견되었다면, 이를 해결하기 위해 코드들을 수정하는 과정에서 미처 정리하지 못한 불필요한 코드(Dead code)가 남게 되고 심한 경우엔 코드가 꼬여지게 된다. 이러한 코드를 스파게티 코드라고 하는데 이 스파게티 코드들은 유지보수를 어렵게 만드는 원인이 된다.

하지만 OOP는 객체와 추상화라는 개념을 통해 앞서 본 절차적 설계의 문제점들을 배제할 수 있다.

``` java
public class Example {
  public void execute() {
    // 음료수 클래스
    Drink cola = new Cola();

    // 자판기 클래스
    VendingMachine machine = new VendingMachine(2000, cola);   // TODO step1 금액과 음료수를 입력한다.

    machine.calculate(); // TODO step3 음료수 재고와 돈을 계산한다.
    machine.resultAction(); // TODO step4 자판기는 음료수와 잔돈을 반환한다.
  }
}
```

먼저 다음 코드를 절차적 코드와 비교해보면 순서보다는 객체라는 시각으로 프로그램을 작성했다는 점을 알 수 있다. 즉 자판기, 음료수를 독립적인 모듈로 바라보고 이를 토대로 클래스로 정의했다.

프로그램은 자판기 프로세스를 수행하기 위해 각 단계에서 필요한 기능을 정의된 클래스를 참조하여 해당 기능을 수행하고 있다. 이처럼 프로그램의 논리적인 순서를 지키는 과정은 절차적 프로그래밍과 유사하지만, 엄밀히 보자면 다르다.

이러한 차이는 자료의 추상화에 있는데, 공통적인 데이터와 동작을 하나의 클래스라는 틀에 정의했기 때문이다. 데이터와 동작을 하나의 틀에 정의함으로써 데이터의 소유권은 각 객체에 의해서 정해지고, 결과적으로 객체지향 설계는 객체라는 하나의 독립적인 모듈을 활용함으로써 기능 간 의존도를 최소화하기 때문에 각 기능을 독립적으로 관리할 수 있게 된다.

특히, OOP는 추상화 설계를 통해 전통적인 제어의 흐름을 바꾼다는 점이다. 예를 들어 데이터 조작이라는 관점에서 보자면 기존의 전통적인 데이터 조작은 분기문을 통해 조작에 필요한 데이터를 코드에 작성했다. 이는 실제 실행될 코드가 미리 정해져 있다는 의미다.

``` javascript
switch (drink) {
  case "콜라":
    drinkAmt = 1500;
  break;

  case "사이다":
    drinkAmt = 1000;
  break;
}
```

 이 말을 달리 말하자면 모든 데이터의 제어권은 개발자에게 있고, 이게 바로 전통적인 제어 흐름이었다. 하지만 OOP는 클래스 추상화 설계를 통해 기존의 데이터의 제어권을 개발자가 아닌 프로그램에게 위임해줌으로써 전통적인 제어 흐름을 뒤바꾼다.

 정리하자면 기능에 필요한 실제 코드는 개발자가 아닌 다른 대상에 의해 실행될 실제 코드가 결정되는데 이를 제어의 역전(IoC, Inversion of Control)라 불린다. 결과적으로 제어의 역전을 통해 개발자는 데이터 조작에 관해 결정하지 않아도 된다는 점이다.

  이러한 예는 위에 정의한 예제 코드를 보면 알 수 있다. 눈치챘을지 모르겠지만, 위의 예제 코드엔 `step2`의 단계가 없다. 이 말은 음료수의 금액을 코드에 정의할 필요가 없고 개발자가 가지고 있던 데이터 제어에 대한 부담을 줄여준다는 의미이다.

  본론으로 돌아와서 우리는 `step2` 단계가 없어진 원인을  찾기 위해선 음료수의 금액이 어디서 정의되는지 알아봐야 한다.

``` java
public void execute() {
  Drink cola = new Cola();
  ...
  machine.calculate(); // TODO step3 음료수 재고와 돈을 계산한다.
  ...
}

interface Drink {
  public String getName();
  public int getAmt();
}

class Cola implements Drink {
  @Override
  public String getName() {
    return "콜라";
  }

  @Override
  public int getAmt() {
    return 1500;
  }
}
```

먼저 코드를 보면 음료수라는 객체를 추상화 설계를 통해 `Drink`라는 인터페이스로 정의하고, 이를 구현한 `Cola`와 `Cidar` 클래스를 만들었다. 이러한 객체의 추상화 설계는 제어의 역전의 발판이 되는데 다음 calculate 메소드를 보면 그 답을 찾을 수 있다.

``` java
void calculate() {
	int drinkAmt = drink.getAmt(); // TODO step2 음료수의 금액을 확인한다.
	...
}
```

 Drink drink라는 추상화 클래스를 VendingMachine 클래스의 Drink 객체를 참조한다. `step1`에서 VendingMachine 클래스의 Drink 객체는 Cola를 주입 받았기 때문에 Drink는 Cola를 대상으로 하고 있다.

<img src="/md/img/oop/oop-flow.png" style="max-height: none;">

이 때문에 drink.getAmt();를 호출하는 순간 데이터가 조작이 되고 Cola 클래스에 정의된 음료수 값을 바라보게 된다. 여기서 중요한 점은 코드상에 분기문 없이 프로그램에 의해 필요한 객체가 정의되어 데이터 조작이 가능하다는 점이다.

### OOP의 이점

 결과적으로 OOP는 순차적으로 실행되는 코드의 위에서 아래의 코드로 어떤 값을 넘기거나 코드의 실행순서를 결정하지 않아도 되고  각 모듈/클래스 별로 정의된 기능이 실행된다.


 이러한 결과들은 OOP는

 OOP는 모든 객체를 모듈화하여 유연하고 유지 보수성이 높은 프로그래밍을 할 수 있도록 의도 되었다.

추상화를 사용하여 객체를 모듈화하는 과정은 추상적 설계를 하도록 유도되었고, 동시에 인터페이스 기반의 설계가 되었다.  모듈의 재사용성을 증가시키고 체계적이고 효율적으로 코드를 관리할 수 있게 되었다.

 결과적으로 추상화 클래스를 통해 객체를 재사용한다는 원초적인 원칙을 통해 코드를 간단하고, 명료하고, 효율적으로 관리할 수 있다.

### OOP의 특징

OOP의 특징엔 캡추다산정이 불리는 캡슐화, 추상화, 다형성, 상속성, 정보 은닉이 있다.

- Encapsulation(캡슐화)
- Abstract(추상화)
- Polymorphism(다형성)
- Inheritance(상속성)
- Information hiding(정보 은닉)

#### Encapsulation(캡슐화)

캡슐화라는 단어를 생각하면 알약을 떠올릴 수 있다.

알약은 하나의 틀안에 여러 성분이 포함되어있는데 이와 마찬가지로 OOP의 캡슐화를 생각하면 되겠다.


캡슐화는 객체 지향 프로그래밍에서 다음 2가지 측면이 있다.

1. 객체의 속성(data fields)과 행위(메서드, methods)를 하나로 묶고
2. 실제 구현 내용 일부를 외부에 감추어 은닉한다.

속성인 데이터와 메서드의 결합은 C++의 경우 멤버함수를 호출할 때 객체의 저장공간을 멤버함수에 넘겨 데이터 처리를 하도록 하는 방법을 사용한다.

외부에 감추는 방법으로는 언어적 측면에서 접근지정자를 두어 은닉의 정도를 기술하여 구현한다. 은닉의 정도를 접근지정자로 기술하고 해당 영역에 들어가는 속성이나 메서드를 제한하면 된다. 접근지정자에 의해 제한된 멤버들은 컴파일러에 의해 판단된다. 언어적 측면에서 접근지정자에 의해 정의된 해당 멤버변수나 멤버함수는 코드 중에 접근방식을 위반한 코드를 작성하면 컴파일 오류로 처리하고 실행코드 생성을 제한한다.

##### 접근제한자

- private : 자기 클래스 내부의 메서드에서만 접근 허용
- protected : 자기 클래스 내부 또는 상속받은 자식 클래스에서 접근 허용
- public : 모든 접근을 허용한다.

---

캡슐화란 관련된 데이터와 알고리즘(코드)이 하나의 묶음으로 정리된 것으로써 개발자가 만들었으며, 관련된 코드와 데이터가 묶여있고 오류가 없어 사용이 편리합니다. 데이터를 감추고 외부 세계와의 상호작용은 메소드를 통하는 방법인데, 라이브러리로 만들어 업그레이드하면 쉽게 바꿀 수 있습니다.

※ 메소드 : 메시지에 따라 실행시킬 프로시저로서 객체지향 언어에서 사용되는 것. 객체지향 언어에서는 메시지를 보내 메소드를 수행시킴으로써 통신(communication)을 수행한다.

Information hiding

---

객체의 상세한 내용을 객체 외부에 철저히 숨기고 단순히 메시지만으로 객체와의 상호작용을 하게 하는 것을 캡슐화(encapsulation)라고 한다. 정보 은닉(information hiding)이라는 표현으로 설명하기도 하는데 추상화와 동일한 개념이다. 캡슐화는 추상화와 거의 같은 개념이지만 추상화를 지원하며 보다 구체적이고 제한적이라고 할 수 있다.

예를 들면, 클래스를 선언하고 그 클래스를 구성하는 객체에 대하여 "public" 또는 "private" 등으로 정의해준다. 이렇게 되면 "public"으로 정의된 함수 또는 데이터는 외부에서 사용이 가능하며, "private"으로 선언된 경우는 외부에서 제어할 수 없고 내부에서만 사용된다.

이것은 클래스 외부에는 제한된 접근 권한을 제공하며 원하지 않는 외부의 접근에 대해 내부를 보호하는 작용을 한다. 이렇게 함으로써 이들 부분이 프로그램의 다른 부분들에 영향을 미치지 않고 변경될 수 있다.

출처: http://tenlie10.tistory.com/1 [게임 개발자 블로그]

#### Abstract(추상화)

유념해야할 부분은 추상화와 자료의추상화는 다른개념이야

 간단히 예를 들자면 추상화라는건 클래스의 설계를 위해서 상속관계/구현 등의 구조를 관계가 느슨하도록 만들면서도 서로 강하게 연결되도록 구조화시키는데 쓰이는 개념이지

 그렇다면 클래스 기반의 언어에서는 추상화를 쓸 수 있다는거네요? 자료의 추상화를 자료를 은닉시키고 상속관계하에서 접근을 제한/허용하는 등의 접근체계를 만드는 개념이지 추상화는 설계의 개념이야

꼭 클래스 기반언어에서만 쓰이는게 아니지  C언어는 추상화 못하나?

굳이 의미를 부여하자면 Module 기반 언어지

---

#### Polymorphism(다형성)

셋째, 다형성이 있습니다. 다형성이란 하나의 이름(방법)으로 많은 상황에 대처하는 기법입니다. 개념적으로 동일한 작업을 하는 함수들에 똑같은 이름을 부여할 수 있으므로 코드가 더 간단해지는 효과가 있습니다.

#### Inheritance(상속성)

둘째, 상속이 있습니다. 상속은 이미 작성된 클래스를 이어 받아서 새로운 클래스를 생성하는 기법으로 위에서 말한 기존 코드를 재활용해서 사용하는 것을 의미합니다. 객체지향 방법의 큰 장점중 하나입니다.

#### Information hiding(정보 은닉)


위의 특성들로 인해 생기는 객체지향 방법의 장점은 다음과 같습니다.

 신뢰성 있는 소프트웨어를 쉽게 작성할 수 있다. (개발자가 만든 데이터를 사용하기에 신뢰할 수 있다.)
 코드를 재사용하기 쉽다.
 업그레이드가 쉽다.
 디버깅이 쉽다.

 객체의 상세한 내용을 객체 외부에 철저히 숨기고 단순히 메시지만으로 객체와의 상호작용을 하게 하는 것을 캡슐화(encapsulation)라고 한다. 정보 은닉(information hiding)이라는 표현으로 설명하기도 하는데 추상화와 동일한 개념이다. 캡슐화는 추상화와 거의 같은 개념이지만 추상화를 지원하며 보다 구체적이고 제한적이라고 할 수 있다.

 예를 들면, 클래스를 선언하고 그 클래스를 구성하는 객체에 대하여 "public" 또는 "private" 등으로 정의해준다. 이렇게 되면 "public"으로 정의된 함수 또는 데이터는 외부에서 사용이 가능하며, "private"으로 선언된 경우는 외부에서 제어할 수 없고 내부에서만 사용된다.

 이것은 클래스 외부에는 제한된 접근 권한을 제공하며 원하지 않는 외부의 접근에 대해 내부를 보호하는 작용을 한다. 이렇게 함으로써 이들 부분이 프로그램의 다른 부분들에 영향을 미치지 않고 변경될 수 있다.

  ---


 3. 상속(Inheritance)



 상속은 클래스의 속성과 행위를 하위 클래스에 물려주거나, 상위 클래스에서 물려받는 것을 지칭한다.



 *상속을 사용하면 좋은점은?



 재사용으로 인한 코드가 줄어든다. 하위 클래스에서 속성이나 행위를 다시 정의하지 않고 상속 받아서 사용함으로써 코드가 줄어든다.
 좀 더 범용성 있게 사용할 수 있다. 예를 들어 Object타입의 매개변수에는 String타입이나 int타입의 객체가 쓰여도 문제되지 않는다. 왜냐하면 String과 int타입 모두 Object타입의 객체를 상속받은 하위 클래스이기 때문이다.


 참고로 하위 클래스는 상위 클래스가 가지고 있는 모든 자료와 메소드를 물려받아 자유롭게 사용할 수 있지만, 또한 자신만의 자료와 메소드를 추가적으로 덧붙임으로써 새로운 형태의 클래스로 발전할 수 있다.



 4. 다형성(Polymorphism)



 다형성은 객체지향의 개념에서 가장 중요한 특징이라고 말할 수 있다. 다형성이란 사전적 의미로 '다양한 형태로 나타날 수 있는 능력'을 뜻한다.



 객체지향 프로그래밍은 하나의 클래스 내부에 같은 이름의 행위를 여럿 정의하거나, 상위 클래스의 오퍼레이션을 하위 클래스에서 다시 정의하여 사용할 수 있기 때문에 바로 이 다형성이라는 특징을 갖는 것이다.


### 객체지향의 5원칙

#### SRP : 단일 책임 원칙


#### OCP : 개방-폐쇄 원칙


#### LSP : 리스코프 치환 원칙


#### ISP : 인터페이스 분리 원칙


#### DIP : 의존성 역전 원칙


### 마무리

OOP의 등장 배경을 설명하기 전에 새로운 기술이 나오는 이유에 대한 주관적인 생각을 말해보려 한다.

개발자들은 태생적으로 게으른 존재고 현재 기술이 비효율적이라고 생각이 들면 자연스레 효과적인 해결 방안을 제시하고 이를 바탕으로 새로운 기술이 나타난다. 이를 근거로 객체의 사용에 대한 물음에 대해 기존의 전통적인 소프트웨어의 개발 방식에서 답을 찾아보려 한다.

앞서 설명을 통해 OOP라는 개념을 처음 알게 되었을진 몰라도 우리는 능숙하게 OOP를 하며 개발하고 있다. 흔히 우리가 사용했던 JAVA가 바로 대표적인 객체지향 언어로 클래스, 메소드, 변수를 사용하며 개발하기 때문이다.


---

### 참고


[나무위키 - 객체지향의 5대 원칙](https://namu.wiki/w/%EA%B0%9D%EC%B2%B4%20%EC%A7%80%ED%96%A5%20%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/%EC%9B%90%EC%B9%99)

 [OOP 객체지향 프로그래밍](http://www.terms.co.kr/OOP.htm)

 [[Java] OOP(객체지향 프로그래밍)의 특징](https://gmlwjd9405.github.io/2018/07/05/oop-features.html)


 [OOP 탄생배경](https://m.blog.naver.com/PostView.nhn?blogId=ghen4268&logNo=110184188778&proxyReferer=https%3A%2F%2Fwww.google.com%2F)

 [OOP 등장 배경, 기본 개념, 특징](https://m.blog.naver.com/PostView.nhn?blogId=mhg1186&logNo=220661553978&proxyReferer=https%3A%2F%2Fwww.google.com%2F)

 [버퍼](http://www.jidum.com/jidums/view.do?jidumId=391)

 [캡슐화는 정보 숨김이 아닙니다.](https://www.javaworld.com/article/2075271/core-java/encapsulation-is-not-information-hiding.html)

[캡슐화(encapsulation)이란?](http://blog.naver.com/PostView.nhn?blogId=netrance&logNo=110096417364)

[anti if oop](https://meetup.toast.com/posts/94)

[Introduction to Object Oriented Programming](http://www.cs.utexas.edu/users/mitra/csSpring2017/cs303/lectures/oop.html)
